using System;
using System.Collections.Generic;
using System.IO;

namespace RT.Util.Serialization
{
    /// <summary>
    ///     Used by <see cref="Classify"/> to serialize and deserialize objects. Implement this to enable serialization to a new
    ///     format.</summary>
    /// <typeparam name="TElement">
    ///     Type of the serialized form of an object or any sub-object.</typeparam>
    public interface IClassifyFormat<TElement>
    {
        /// <summary>
        ///     Reads the serialized form from a stream.</summary>
        /// <param name="stream">
        ///     Stream to read from.</param>
        /// <returns>
        ///     The serialized form read from the stream.</returns>
        TElement ReadFromStream(Stream stream);

        /// <summary>
        ///     Writes the serialized form to a stream.</summary>
        /// <param name="element">
        ///     Serialized form to write to the stream.</param>
        /// <param name="stream">
        ///     Stream to write to.</param>
        void WriteToStream(TElement element, Stream stream);

        /// <summary>
        ///     Determines whether the specified element represents a <c>null</c> value.</summary>
        /// <remarks>
        ///     This should return <c>true</c> if the element was generated by <see cref="FormatNullValue"/> and <c>false</c>
        ///     otherwise.</remarks>
        bool IsNull(TElement element);

        /// <summary>
        ///     Called when Classify expects the element to be one of the following types: <c>byte</c>, <c>sbyte</c>,
        ///     <c>short</c>, <c>ushort</c>, <c>int</c>, <c>uint</c>, <c>long</c>, <c>ulong</c>, <c>decimal</c>, <c>float</c>,
        ///     <c>double</c>, <c>bool</c>, <c>char</c>, <c>string</c>, <c>DateTime</c> or an enum type. The implementation is
        ///     free to return a value of any of these types, and Classify will automatically use <see cref="ExactConvert"/> to
        ///     convert the value to the required target type.</summary>
        /// <remarks>
        ///     This should decode values passed into <see cref="FormatSimpleValue"/>, although it is acceptable if the type has
        ///     changed, as long as <see cref="ExactConvert"/> will convert the decoded value back to the original
        ///     value.</remarks>
        object GetSimpleValue(TElement element);

        /// <summary>
        ///     Decodes the serialized form of the element type itself.</summary>
        /// <remarks>
        ///     This should do the reverse of <see cref="FormatSelfValue"/>.</remarks>
        TElement GetSelfValue(TElement element);

        /// <summary>
        ///     Decodes a list.</summary>
        /// <param name="element">
        ///     The element to decode.</param>
        /// <param name="tupleSize">
        ///     If null, a variable-length list is expected; otherwise, a fixed-length list (a tuple) is expected.</param>
        /// <returns>
        ///     A collection containing the sub-elements contained in the list. The collection returned need not have the size
        ///     specified by <paramref name="tupleSize"/>.</returns>
        /// <remarks>
        ///     This should do the reverse of <see cref="FormatList"/>.</remarks>
        IEnumerable<TElement> GetList(TElement element, int? tupleSize);

        /// <summary>
        ///     Decodes a key-value pair.</summary>
        /// <param name="element">
        ///     The element to decode.</param>
        /// <param name="key">
        ///     Receives the key part of the pair.</param>
        /// <param name="value">
        ///     Receives the value part of the pair.</param>
        /// <remarks>
        ///     This should do the reverse of <see cref="FormatKeyValuePair"/>.</remarks>
        void GetKeyValuePair(TElement element, out TElement key, out TElement value);

        /// <summary>
        ///     Decodes a dictionary.</summary>
        /// <param name="element">
        ///     The element to decode.</param>
        /// <returns>
        ///     A collection containing the key/value pairs in the dictionary. The keys in the returned collection are expected to
        ///     be convertible to the correct type using <see cref="ExactConvert"/>.</returns>
        /// <remarks>
        ///     This should decode values passed into <see cref="FormatDictionary"/>, although it is acceptable if the type of the
        ///     keys has changed. For example, all keys may be returned as <c>string</c>, as long as <see cref="ExactConvert"/>
        ///     will convert that <c>string</c> back to the original value.</remarks>
        IEnumerable<KeyValuePair<object, TElement>> GetDictionary(TElement element);

        /// <summary>
        ///     Determines whether the element is an object and contains a sub-element for the specified field.</summary>
        /// <param name="element">
        ///     The element that may represent an object.</param>
        /// <param name="fieldName">
        ///     The name of the field sought.</param>
        /// <param name="declaringType">
        ///     The assembly-qualified name of the type that declares the field. (This can be null if the field name is unique
        ///     within the type of the object being deserialized.)</param>
        /// <returns>
        ///     <c>true</c> if <paramref name="element"/> is an object and has the specified field; <c>false</c>
        ///     otherwise.</returns>
        /// <remarks>
        ///     This should return <c>true</c> if <paramref name="element"/> represents an element generated by <see
        ///     cref="FormatObject"/> in which the field with the specified <paramref name="fieldName"/> was present.</remarks>
        bool HasField(TElement element, string fieldName, string declaringType);

        /// <summary>
        ///     Returns the sub-element pertaining to the specified field.</summary>
        /// <param name="element">
        ///     The element that represents an object.</param>
        /// <param name="fieldName">
        ///     The name of the field within the object whose sub-element is sought.</param>
        /// <param name="declaringType">
        ///     The assembly-qualified name of the type that declares the field. (This can be null if the field name is unique
        ///     within the type of the object being deserialized.)</param>
        /// <returns>
        ///     The sub-element for the specified field.</returns>
        /// <remarks>
        ///     <para>
        ///         Classify calls <see cref="HasField"/> first for each field and only calls this method if <see
        ///         cref="HasField"/> returned true.</para>
        ///     <para>
        ///         This should return the same element that was passed into <see cref="FormatObject"/> for the same <paramref
        ///         name="fieldName"/>.</para></remarks>
        TElement GetField(TElement element, string fieldName, string declaringType);

        /// <summary>
        ///     Determines the type of the object stored in the specified element.</summary>
        /// <param name="element">
        ///     The element that represents an object.</param>
        /// <param name="isFullType">
        ///     Receives a value indicating whether the type is a fully-qualified type name or not. This value is ignored if the
        ///     method returns <c>null</c>.</param>
        /// <returns>
        ///     <c>null</c> if no type information was persisted in this element; otherwise, the decoded type name.</returns>
        /// <remarks>
        ///     This should decode the information (the string and the boolean) encoded by <see cref="FormatWithType"/>.</remarks>
        string GetType(TElement element, out bool isFullType);

        /// <summary>
        ///     Determines whether this element represents a reference to another object in the same serialized graph.</summary>
        /// <param name="element">
        ///     The element to decode.</param>
        /// <returns>
        ///     <c>true</c> if this element represents such a reference; <c>false</c> otherwise.</returns>
        /// <remarks>
        ///     This should recognize elements generated by <see cref="FormatReference"/>.</remarks>
        bool IsReference(TElement element);

        /// <summary>
        ///     Determines whether this element represents an object that can be referred to by a reference element.</summary>
        /// <param name="element">
        ///     The element to decode.</param>
        /// <returns>
        ///     <c>true</c> if this element is referable; <c>false</c> otherwise.</returns>
        /// <remarks>
        ///     This should recognize elements generated by <see cref="FormatReferable"/>.</remarks>
        bool IsReferable(TElement element);

        /// <summary>
        ///     Determines whether this element represents a reference to another file. See <see
        ///     cref="ClassifyFollowIdAttribute"/> for details.</summary>
        /// <param name="element">
        ///     The element to decode.</param>
        /// <returns>
        ///     <c>true</c> if this element is such a reference; <c>false</c> otherwise.</returns>
        /// <remarks>
        ///     This should recognize elements generated by <see cref="FormatFollowID"/>.</remarks>
        bool IsFollowID(TElement element);

        /// <summary>
        ///     Returns the ID encoded in this element. This is called only if <see cref="IsReference"/> or <see
        ///     cref="IsReferable"/> returned <c>true</c>.</summary>
        /// <param name="element">
        ///     The element to decode.</param>
        /// <returns>
        ///     The ID encoded in this element.</returns>
        /// <remarks>
        ///     This should return the same ID that was passed into <see cref="FormatReference"/> or <see
        ///     cref="FormatReferable"/>.</remarks>
        int GetReferenceID(TElement element);

        /// <summary>
        ///     Returns the ID encoded in this element. This is called only if <see cref="IsFollowID"/> returned
        ///     <c>true</c>.</summary>
        /// <param name="element">
        ///     The element to decode.</param>
        /// <returns>
        ///     The ID encoded in this element.</returns>
        /// <remarks>
        ///     This should return the same ID that was passed into <see cref="FormatFollowID"/>.</remarks>
        string GetFollowID(TElement element);

        /// <summary>
        ///     Generates an element that represents a <c>null</c> value.</summary>
        /// <returns>
        ///     The serialized form of the <c>null</c> value.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="IsNull"/>.</remarks>
        TElement FormatNullValue();

        /// <summary>
        ///     Generates an element that represents a <c>byte</c>, <c>sbyte</c>, <c>short</c>, <c>ushort</c>, <c>int</c>,
        ///     <c>uint</c>, <c>long</c>, <c>ulong</c>, <c>decimal</c>, <c>float</c>, <c>double</c>, <c>bool</c>, <c>char</c>,
        ///     <c>string</c>, <c>DateTime</c> or an enum value.</summary>
        /// <param name="value">
        ///     The value to encode.</param>
        /// <returns>
        ///     The serialized form of the <paramref name="value"/>.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="GetSimpleValue"/>, but need not necessarily decode to the
        ///     same type, as long as <see cref="ExactConvert"/> will convert it to the correct value.</remarks>
        TElement FormatSimpleValue(object value);

        /// <summary>
        ///     Generates an element that represents a value of the same type as serialized elements.</summary>
        /// <param name="value">
        ///     The value to encode.</param>
        /// <returns>
        ///     The serialized form of the <paramref name="value"/>.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="GetSelfValue"/>.</remarks>
        TElement FormatSelfValue(TElement value);

        /// <summary>
        ///     Generates an element that represents a list.</summary>
        /// <param name="isTuple">
        ///     Specifies whether we are serializing a variable-length list, or a tuple (fixed-length list).</param>
        /// <param name="values">
        ///     The values to put into list form.</param>
        /// <returns>
        ///     The serialized list.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="GetList"/>.</remarks>
        TElement FormatList(bool isTuple, IEnumerable<TElement> values);

        /// <summary>
        ///     Generates an element that represents a key-value pair.</summary>
        /// <param name="key">
        ///     The element that represents the key.</param>
        /// <param name="value">
        ///     The element that represents the value.</param>
        /// <returns>
        ///     The serialized key-value pair.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="GetKeyValuePair"/>.</remarks>
        TElement FormatKeyValuePair(TElement key, TElement value);

        /// <summary>
        ///     Generates an element that represents a dictionary.</summary>
        /// <param name="values">
        ///     The key-value pairs that compose the dictionary. The keys may be <c>string</c>s, integers, or enum values.</param>
        /// <returns>
        ///     The serialized dictionary.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="GetDictionary"/>.</remarks>
        TElement FormatDictionary(IEnumerable<KeyValuePair<object, TElement>> values);

        /// <summary>
        ///     Generates an element that represents an object with fields.</summary>
        /// <param name="fields">
        ///     A collection of objects containing each fields’ identifying information and serialized value.</param>
        /// <returns>
        ///     The serialized object.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="HasField"/> and <see cref="GetField"/>, irrespective of
        ///     the order in which the fields are provided in <paramref name="fields"/>.</remarks>
        TElement FormatObject(IEnumerable<ObjectFieldInfo<TElement>> fields);

        /// <summary>
        ///     Generates an element that represents a reference to another file.</summary>
        /// <param name="id">
        ///     The reference ID.</param>
        /// <returns>
        ///     An element that represents a reference to another file with the specified <paramref name="id"/>.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="IsFollowID"/>.</remarks>
        TElement FormatFollowID(string id);

        /// <summary>
        ///     Generates an element that represents a reference to another object within the same serialized object
        ///     graph.</summary>
        /// <param name="refId">
        ///     The reference ID.</param>
        /// <returns>
        ///     An element that represents a reference to another object with the specified <paramref name="refId"/>.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="IsReference"/>.</remarks>
        TElement FormatReference(int refId);

        /// <summary>
        ///     Converts an existing element (which may represent, for example, an object, list or dictionary) into one that can
        ///     be referred to by a reference (see <see cref="FormatReference"/>).</summary>
        /// <param name="element">
        ///     The original element to be converted.</param>
        /// <param name="refId">
        ///     The reference ID.</param>
        /// <returns>
        ///     A representation of the original <paramref name="element"/>, which additionally encodes the referable <paramref
        ///     name="refId"/>.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="IsReferable"/> as well as all the other methods that would
        ///     have also recognized the original <paramref name="element"/>.</remarks>
        TElement FormatReferable(TElement element, int refId);

        /// <summary>
        ///     Converts an existing element (which may represent, for example, an object, list or dictionary) into one that
        ///     additionally knows its type.</summary>
        /// <param name="element">
        ///     The original element to be converted.</param>
        /// <param name="type">
        ///     A string that identifies the type of the object.</param>
        /// <param name="isFullType">
        ///     A value indicating whether this is a fully-qualified type name or not.</param>
        /// <returns>
        ///     A representation of the original <paramref name="element"/>, which additionally encodes the <paramref
        ///     name="type"/>.</returns>
        /// <remarks>
        ///     The returned element should be recognized by <see cref="GetType"/> as well as all the other methods that would
        ///     have also recognized the original <paramref name="element"/>.</remarks>
        TElement FormatWithType(TElement element, string type, bool isFullType);
    }

    /// <summary>
    ///     Encapsulates information about a field in an object and its value.</summary>
    /// <typeparam name="TElement">
    ///     Type of serialized form used in <see cref="IClassifyFormat{TElement}"/>.</typeparam>
    public sealed class ObjectFieldInfo<TElement>
    {
        /// <summary>The name of the field.</summary>
        public string FieldName { get; private set; }
        /// <summary>
        ///     The assembly-qualified name of the type that declares the field, or null if the name of the field is unique within
        ///     the object being serialized.</summary>
        public string DeclaringType { get; private set; }
        /// <summary>The value of the field.</summary>
        public TElement Value { get; private set; }

        /// <summary>
        ///     Constructor.</summary>
        /// <param name="fieldName">
        ///     The name of the field.</param>
        /// <param name="declaringType">
        ///     The assembly-qualified name of the type that declares the field, or null if the name of the field is unique within
        ///     the object being serialized.</param>
        /// <param name="value">
        ///     The value of the field.</param>
        public ObjectFieldInfo(string fieldName, string declaringType, TElement value)
        {
            FieldName = fieldName;
            DeclaringType = declaringType;
            Value = value;
        }
    }
}
