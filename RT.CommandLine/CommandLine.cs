using System.Diagnostics;
using System.Reflection;
using RT.Lingo;
using RT.PostBuild;
using RT.Serialization;
using RT.Util;
using RT.Util.Consoles;
using RT.Util.ExtensionMethods;
using RT.Util.Text;

namespace RT.CommandLine;

/// <summary>
///     Implements a command-line parser that can turn the commands and options specified by the user on the command line into
///     a strongly-typed instance of a specific class. See remarks for more details.</summary>
/// <remarks>
///     <para>
///         The following conditions must be met by the class wishing to receive the options and parameters:</para>
///     <list type="bullet">
///         <item><description>
///             It must be a reference type (a class), must have <see cref="CommandLineAttribute"/>, and it must have a
///             parameterless constructor (unless it has subcommands, see below).</description></item>
///         <item><description>
///             <para>
///                 Every field in the class must have one of the following custom attributes:</para>
///             <list type="bullet">
///                 <item><description>
///                     <see cref="IsPositionalAttribute"/> (allowed for all supported types except <c>bool</c>) — specifies
///                     that the parameter is positional; the user specifies the value(s) in place without an option preceding
///                     it.</description></item>
///                 <item><description>
///                     <see cref="OptionAttribute"/> (allowed for all supported types) — specifies that the parameter invoked
///                     by an option, e.g. <c>-x</c>, which may or may not be followed by a value. (This does not imply that
///                     the parameter is necessarily optional.)</description></item>
///                 <item><description>
///                     <see cref="EnumOptionsAttribute"/> (allowed for enum types only) — specifies that the parameter can be
///                     invoked by one of several options, which are specified on the enum values in the enum type.</description></item>
///                 <item><description>
///                     <see cref="IgnoreAttribute"/> — specifies that <see cref="CommandLineParser"/> shall completely ignore
///                     the field.</description></item></list></description></item>
///         <item><description>
///             <para>
///                 Each field may optionally have any of the following custom attributes:</para>
///             <list type="bullet">
///                 <item><description>
///                     <see cref="IsMandatoryAttribute"/> (allowed for all supported types except <c>bool</c>) — specifies
///                     that the parameter must be specified by the user. For a <c>string[]</c> field, it means that at least
///                     one value must be specified.</description></item>
///                 <item><description>
///                     <see cref="UndocumentedAttribute"/> — specifies that the option or command does not appear in the help
///                     screen generated by CommandLineParser.</description></item></list></description></item>
///         <item><description>
///             <para>
///                 Each field in the class must be of one of the following types:</para>
///             <list type="bullet">
///                 <item><description>
///                     <c>string</c>, any integer type, <c>float</c>, <c>double</c>, or any nullable version of these. The
///                     field can be positional (<see cref="IsPositionalAttribute"/>) or not (<see cref="OptionAttribute"/>).</description></item>
///                 <item><description>
///                     <c>string[]</c>. The field can be positional (<see cref="IsPositionalAttribute"/>) or not (<see
///                     cref="OptionAttribute"/>), but if it is positional, it must be the last positional parameter.</description></item>
///                 <item><description>
///                     <c>bool</c>. The field must have an <see cref="OptionAttribute"/> and cannot be positional or
///                     mandatory.</description></item>
///                 <item><description>
///                     <para>
///                         Any enum type. There are three ways that enum types can be used. To explain these, the following
///                         enum type declaraction is used as an example:</para>
///                     <code>
///                         enum OutputFormat { PlainText, Xml }</code>
///                     <list type="bullet">
///                         <item><description>
///                             <para>
///                                 <see cref="IsPositionalAttribute"/> — The user can specify a single parameter (e.g.
///                                 <c>plain</c> or <c>xml</c>) to select an enum value. Every value in the enum type must
///                                 have a <see cref="CommandNameAttribute"/> to specify the name by which that enum value is
///                                 selected:</para>
///                             <code>
///                                 enum OutputFormat
///                                 {
///                                     [CommandName("plain")]
///                                     PlainText,
///                                     [CommandName("xml")]
///                                     Xml
///                                 }</code></description></item>
///                         <item><description>
///                             <see cref="OptionAttribute"/> — The user can select an enum value by specifying an option
///                             followed by a parameter that identifies the enum value (e.g. <c>-f plain</c> or <c>-f
///                             xml</c>). As above, every value in the enum type must have a <see
///                             cref="CommandNameAttribute"/> to specify the name by which that enum value is selected.</description></item>
///                         <item><description>
///                             <para>
///                                 <see cref="EnumOptionsAttribute"/> — The user can select an enum value by specifying just
///                                 an option (e.g. <c>-p</c> or <c>-x</c>). Every value in the enum type must have an <see
///                                 cref="OptionAttribute"/> to specify the option by which that enum value is selected:</para>
///                             <code>
///                                 enum OutputFormat
///                                 {
///                                     [Option("-p", "--plain")]
///                                     PlainText,
///                                     [Option("-x", "--xml")]
///                                     Xml
///                                 }</code>
///                             <para>
///                                 A parameter on the attribute determines whether the user is allowed to specify only one
///                                 enum value or multiple (which will be combined using bitwise or).</para></description></item>
///                         <item><description>
///                             If the field is optional, the enum value that corresponds to the field’s initial (default)
///                             value may omit the <see cref="CommandNameAttribute"/> or <see cref="OptionAttribute"/>.</description></item></list></description></item></list></description></item>
///         <item><description>
///             <para>
///                 Every field must have documentation or be explicitly marked with <see cref="UndocumentedAttribute"/>
///                 (except for fields that use <see cref="EnumOptionsAttribute"/> or <see cref="IgnoreAttribute"/>). For
///                 every field whose type is an enum type, the values in the enum type must also have documentation or <see
///                 cref="UndocumentedAttribute"/>, except for the enum value that corresponds to the field’s default value if
///                 the field is not mandatory.</para>
///             <para>
///                 Documentation is provided in one of the following ways:</para>
///             <list type="bullet">
///                 <item><description>
///                     Monolingual, translation-agnostic (unlocalizable) applications use the <see
///                     cref="DocumentationAttribute"/> to specify documentation directly.</description></item>
///                 <item><description>
///                     <para>
///                         Translatable applications must declare methods with the following signature:</para>
///                     <code>
///                         static string FieldNameDoc(Translation)</code>
///                     <para>
///                         The first parameter must be of the same type as the object passed in for the <c>applicationTr</c>
///                         parameter of <see cref="Parse"/>. The name of the method is the name of the field or enum value
///                         followed by <c>Doc</c>. The return value is the translated string.</para></description></item></list></description></item>
///         <item><description>
///             <see cref="IsPositionalAttribute"/> and <see cref="IsMandatoryAttribute"/> can be used together. However, a
///             positional field can only be made mandatory if all the positional fields preceding it are also mandatory.</description></item></list>
///     <para>
///         Subcommands can be implemented by using derived classes. For example, in order to allow the user to invoke
///         commands of the following form:</para>
///     <code>
///         MyTool.exe create new_item
///         MyTool.exe rename old_name new_name</code>
///     <para>
///         you would declare the following classes:</para>
///     <code>
///         [CommandLine]
///         abstract class CmdBase { }
///
///         [CommandName("create")]
///         sealed class CmdCreate : CmdBase
///         {
///             [IsPositional, IsMandatory]
///             public string ItemName;
///         }
///
///         [CommandName("rename")]
///         sealed class CmdRename : CmdBase
///         {
///             [IsPositional, IsMandatory]
///             public string OldName;
///             [IsPositional, IsMandatory]
///             public string NewName;
///         }</code>
///     <para>
///         In this example, we have omitted the documentation attributes, but in practice they would be required. The
///         following points are of note here:</para>
///     <list type="bullet">
///         <item><description>
///             <para>
///                 The class <c>CmdBase</c> is abstract to indicate that the subcommand is mandatory. The class could be made
///                 non-abstract to indicate that the subcommand is optional.</para></description></item>
///         <item><description>
///             <para>
///                 The class <c>CmdBase</c> does not need to have a parameterless constructor because only <c>CmdCreate</c>
///                 and <c>CmdRename</c> would actually be instantiated by CommandLineParser. However, if it were
///                 non-abstract, it would need a parameterless constructor.</para></description></item>
///         <item><description>
///             <para>
///                 Parameters that pertain to all subcommands can be added in <c>CmdBase</c> and the user would specify those
///                 before the command name.</para></description></item>
///         <item><description>
///             <para>
///                 You can have any arbitrary multi-level class hierarchy. Only classes marked with <see
///                 cref="CommandNameAttribute"/> become subcommands.</para></description></item></list></remarks>
public static class CommandLineParser
{
    /// <summary>
    ///     Parses the specified command-line arguments into an instance of the specified type. See the remarks section of the
    ///     documentation for <see cref="CommandLineParser"/> for features and limitations.</summary>
    /// <typeparam name="TArgs">
    ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
    /// <param name="args">
    ///     The command-line arguments to be parsed.</param>
    /// <param name="applicationTr">
    ///     Specifies the application’s translation object which contains the localised strings that document the command-line
    ///     options and commands. This object is passed in to the <c>FieldNameDoc</c> methods described in the documentation
    ///     for <see cref="CommandLineParser"/>. This should be <c>null</c> for monoligual applications.</param>
    /// <param name="helpProcessor">
    ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
    ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
    /// <returns>
    ///     An instance of the class <typeparamref name="TArgs"/> containing the options and parameters specified by the user
    ///     on the command line.</returns>
    public static TArgs Parse<TArgs>(string[] args, TranslationBase applicationTr = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
    {
        return (TArgs) parseCommandLine(getCommandInfo(typeof(TArgs)), args, 0, applicationTr, helpProcessor);
    }

    /// <summary>
    ///     Parses the specified command-line arguments into an instance of the specified type. In case of failure, prints
    ///     usage information to the console and returns <c>default(TArgs)</c>. See the remarks section of the documentation
    ///     for <see cref="CommandLineParser"/> for features and limitations.</summary>
    /// <typeparam name="TArgs">
    ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
    /// <param name="args">
    ///     The command-line arguments to be parsed.</param>
    /// <param name="applicationTr">
    ///     Specifies the application’s translation object which contains the localized strings that document the command-line
    ///     options and commands. This object is passed in to the FieldNameDoc() methods described in the documentation for
    ///     <see cref="CommandLineParser"/>. This should be null for monoligual applications.</param>
    /// <param name="cmdLineTr">
    ///     Specifies a translation object that contains the localized strings for CommandLineParser’s own text.</param>
    /// <param name="helpProcessor">
    ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
    ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
    /// <returns>
    ///     An instance of the class <typeparamref name="TArgs"/> containing the options and parameters specified by the user
    ///     on the command line.</returns>
    public static TArgs ParseOrWriteUsageToConsole<TArgs>(string[] args, TranslationBase applicationTr = null, Translation cmdLineTr = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
    {
        try
        {
            return Parse<TArgs>(args, applicationTr, helpProcessor);
        }
        catch (CommandLineParseException e)
        {
            e.WriteUsageInfoToConsole(applicationTr, cmdLineTr, helpProcessor);
            return default(TArgs);
        }
    }

    private static CommandInfo getCommandInfo(Type type)
    {
        return new CommandInfo { Elements = getCommandLineElements(type).ToArray(), Type = type };
    }

    private static IEnumerable<CmdLineElement> getCommandLineElements(Type type)
    {
        var haveSeenOptionalPositional = false;
        foreach (var fieldForeach in getEligibleFields(type))
        {
            var field = fieldForeach; // This is necessary for the lambda expressions to work

            if (field.IsDefined<IgnoreAttribute>())
                continue;

            var positional = field.IsDefined<IsPositionalAttribute>();
            var mandatory = field.IsDefined<IsMandatoryAttribute>();

            if (positional && mandatory && haveSeenOptionalPositional)
                throw new InternalErrorException("Cannot have positional mandatory parameter after a positional optional one.");

            if (positional && !mandatory)
                haveSeenOptionalPositional = true;

            // ### ENUM fields
            if (field.FieldType.IsEnum)
            {
                // ### ENUM fields, positional
                if (positional)
                    yield return new CmdLineEnumFieldPositional { IsMandatory = mandatory, Field = field };

                // ### ENUM fields, non-positional
                else
                {
                    // Take care of both option+name scheme (e.g. “-x foo -x bar”) and option scheme (e.g. “-x -y”)
                    var behavior = field.GetCustomAttributes<EnumOptionsAttribute>().Select(eoa => eoa.Behavior).FirstOrDefault(EnumBehavior.SingleValue);
                    var underlyingType = field.FieldType.GetEnumUnderlyingType();
                    var option = field.GetCustomAttributes<OptionAttribute>().FirstOrDefault();
                    if (option == null)
                    {
                        var enumFields = field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public)
                            .SelectMany(f => f.GetOrderedOptionAttributeNames().Select(name => Ut.KeyValuePair(name, f.GetRawConstantValue())))
                            .ToArray();
                        yield return new CmdLineEnumOptions
                        {
                            Behavior = behavior,
                            Field = field,
                            IsMandatory = mandatory,
                            Options = enumFields.Select(inf => inf.Key).ToArray(),
                            OptionToValue = enumFields.ToDictionary()
                        };
                    }
                    else
                    {
                        yield return new CmdLineEnumOptionWithNames
                        {
                            Behavior = behavior,
                            Options = option.Names,
                            Field = field,
                            IsMandatory = mandatory,
                            NameToValue = field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public)
                                .SelectMany(f => f.GetCustomAttributes<CommandNameAttribute>().SelectMany(cna => cna.Names).Select(name => Ut.KeyValuePair(name, f.GetRawConstantValue())))
                                .ToDictionary()
                        };
                    }
                }
            }

            // ### BOOL fields
            else if (field.FieldType == typeof(bool))
                yield return new CmdLineBoolOption { IsMandatory = mandatory, Field = field, Options = field.GetOrderedOptionAttributeNames() };

            // ### STRING and INTEGER fields (including nullable)
            else if (field.FieldType == typeof(string) || ExactConvert.IsTrueIntegerType(field.FieldType) || ExactConvert.IsTrueIntegerNullableType(field.FieldType) ||
                field.FieldType == typeof(float) || field.FieldType == typeof(float?) || field.FieldType == typeof(double) || field.FieldType == typeof(double?))
            {
                if (positional)
                    yield return new CmdLineOtherPositional { Field = field, IsMandatory = mandatory };
                else
                    yield return new CmdLineOtherOption { Field = field, IsMandatory = mandatory, Options = field.GetOrderedOptionAttributeNames() };
            }

            // ### STRING[] fields
            else if (field.FieldType == typeof(string[]))
            {
                if (positional)
                    yield return new CmdLineStringArrayPositional { Field = field, IsMandatory = mandatory };
                else
                    yield return new CmdLineStringArrayOption { Field = field, IsMandatory = mandatory, Options = field.GetOrderedOptionAttributeNames() };
            }
            else
                // This only happens if the post-build check didn't run
                throw new InternalErrorException("{0}.{1} is not of a supported type.".Fmt(type.FullName, field.Name));
        }

        // ### Command names

        // See if the class has subclasses that represent subcommands
        var derivedTypes = getDirectSubcommands(type);
        if (derivedTypes.Length > 0)
        {
            yield return new CmdLineSubcommand
            {
                IsMandatory = type.IsAbstract,
                Type = type,
                Subcommands = derivedTypes.Select(t => new SubcommandInfo
                {
                    Elements = getCommandLineElements(t).ToArray(),
                    Names = t.GetCustomAttributes<CommandNameAttribute>().First().Names,
                    Type = t
                }).ToArray()
            };
        }
    }

    private static FieldInfo[] getEligibleFields(Type type)
    {
        var bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;

        // Get all fields from the type
        var fields = type.GetFields(bindingFlags).ToList();

        // Keep adding fields from the base type until we find one with CommandNameAttribute or CommandLineAttribute
        var testType = type.BaseType;
        while (testType != typeof(object) && !testType.IsDefined<CommandNameAttribute>() && !testType.IsDefined<CommandLineAttribute>())
        {
            fields.AddRange(testType.GetFields(bindingFlags));
            testType = testType.BaseType;
        }

        return fields.ToArray();
    }

    private static Type[] getDirectSubcommands(Type type)
    {
        var types = AppDomain.CurrentDomain.GetAssemblies().SelectMany(asm => asm.GetTypes()).Where(t => !t.IsGenericTypeDefinition && t.IsSubclassOf(type) && t.IsDefined<CommandNameAttribute>()).ToList();
        types.RemoveAll(t => types.Any(t.IsSubclassOf));
        return types.ToArray();
    }

    private static object parseCommandLine(CommandInfo cmd, string[] args, int i, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        if (i < args.Length)
            if (args[i] == "-?" || args[i] == "/?" || args[i] == "--?" || args[i] == "/h" || args[i] == "--help" || args[i] == "-help" || args[i] == "help")
                throw new CommandLineHelpRequestedException(cmd);

        var elements = cmd.Elements;
        var missingMandatories = new HashSet<CmdLineElement>(elements.Where(e => e.IsMandatory));
        var positionals = elements.Where(e => e.IsPositional).ToQueue();
        var actionsToPerform = new List<Action<object>>();

        bool suppressOptions = false;
        object ret = null;

        while (i < args.Length)
        {
            if (args[i] == "--" && !suppressOptions)
            {
                suppressOptions = true;
                i++;
            }
            else if (!suppressOptions && args[i].StartsWith('-'))
            {
                CmdLineElement el = null;
                foreach (var element in elements.Where(e => !e.IsPositional))
                {
                    if (element.ProcessParameter(args, ref i, actionsToPerform, suppressOptions, helpProcessor, cmd))
                    {
                        el = element;
                        break;
                    }
                }
                if (el == null)
                    throw new UnrecognizedCommandOrOptionException(args[i], cmd);
                missingMandatories.Remove(el);
            }
            else    // positional
            {
                if (positionals.Count == 0)
                    throw new UnexpectedArgumentException(args.Subarray(i), cmd);
                var positional = positionals.Dequeue();
                // This should only return true or throw an exception
                Ut.Assert(positional.ProcessParameter(args, ref i, actionsToPerform, suppressOptions, helpProcessor, cmd));
                if (positional is CmdLineSubcommand)
                {
                    // Special case: recursive call
                    ret = parseCommandLine(((CmdLineSubcommand) positional).Subcommand, args, i, applicationTr, helpProcessor);
                    i = args.Length;
                }
                else if (positional is CmdLineStringArrayPositional)
                {
                    // Special case: this positional remains in the queue forever
                    positionals.Enqueue(positional);
                }
                missingMandatories.Remove(positional);
            }
        }

        if (positionals.Count > 0)
            positionals.Dequeue().ProcessEndOfParameters(actionsToPerform, cmd);

        foreach (var m in missingMandatories)
            m.ProcessEndOfParameters(actionsToPerform, cmd);

        if (ret == null)  // there was no subcommand
            ret = Activator.CreateInstance(cmd.Type, true);

        foreach (var action in actionsToPerform)
            action(ret);

        Type[] typeParam;
        ConsoleColoredString error = null;
        if (cmd.Type.TryGetGenericParameters(typeof(ICommandLineValidatable<>), out typeParam))
        {
            var tp = typeof(ICommandLineValidatable<>).MakeGenericType(typeParam[0]);
            if (typeParam[0] != applicationTr.GetType())
                throw new CommandLineValidationException(@"The type {0} implements {1}, but ApplicationTr is of type {2}. If ApplicationTr is right, the interface implemented should be {3}.".Fmt(
                    cmd.Type.FullName,
                    tp.FullName,
                    applicationTr.GetType().FullName,
                    typeof(ICommandLineValidatable<>).MakeGenericType(applicationTr.GetType()).FullName
                ), cmd);

            var meth = tp.GetMethod("Validate");
            if (meth == null || !meth.GetParameters().Select(p => p.ParameterType).SequenceEqual(new Type[] { typeParam[0] }))
                throw new CommandLineValidationException(@"Couldn’t find the Validate method in the {0} type.".Fmt(tp.FullName), cmd);

            error = (ConsoleColoredString) meth.Invoke(ret, new object[] { applicationTr });
        }
        else if (typeof(ICommandLineValidatable).IsAssignableFrom(cmd.Type))
            error = ((ICommandLineValidatable) ret).Validate();

        if (error != null)
            throw new CommandLineValidationException(error, cmd);

        return ret;
    }

    internal static ConsoleColoredString GenerateHelp(CommandInfo cmd, int? wrapWidth = null, TranslationBase applicationTr = null, Translation tr = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
    {
        helpProcessor = helpProcessor ?? (s => s);

        if (tr == null)
            tr = new Translation();

        int leftMargin = 3;
        var wrapToWidth = wrapWidth ?? ConsoleUtil.WrapToWidth();

        var helpString = new List<ConsoleColoredString>();
        var commandNameAttr = cmd.Type.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
        string commandName = commandNameAttr == null ? Process.GetCurrentProcess().ProcessName : "... " + commandNameAttr.Names.OrderByDescending(c => c.Length).First();

        //
        //  ##  CONSTRUCT THE “USAGE” LINE
        //
        var usage = new List<ConsoleColoredString>();
        usage.Add(new ConsoleColoredString(tr.Usage + " ", CmdLineColor.UsageLinePrefix));
        usage.Add(commandName);

        // Options must be listed before positionals because if a positional is a subcommand, all the options must be before it.
        // Optional positionals must come after mandatory positionals because that is the order they must be specified in.
        // If any mandatory positional is a subcommand, then you can’t have any optional positionals anyway.
        var elements = cmd.Elements.Order().ToArray();
        foreach (var elem in elements)
            usage.Add(" " + elem.UsageString);

        // Word-wrap the usage line
        foreach (var line in new ConsoleColoredString(usage.ToArray()).WordWrap(wrapToWidth, tr.Usage.Translation.Length + 1))
        {
            helpString.Add(line);
            helpString.Add(ConsoleColoredString.NewLine);
        }
        helpString.Add(ConsoleColoredString.NewLine);

        //
        //  ##  CONSTRUCT THE TABLES
        //
        var anyCommandsWithSuboptions = false;

        // Word-wrap the documentation for the command (if any)
        var doc = cmd.Type.GetDocumentation(cmd.Type, applicationTr, helpProcessor);
        foreach (var line in doc.WordWrap(wrapToWidth))
        {
            helpString.Add(line);
            helpString.Add(ConsoleColoredString.NewLine);
        }

        // Table of required parameters
        if (elements.Any(e => e.IsMandatory))
        {
            var requiredParamsTable = new TextTable { MaxWidth = wrapToWidth - leftMargin, ColumnSpacing = 3, RowSpacing = 1, LeftMargin = leftMargin };
            int requiredRow = 0;
            foreach (var f in elements.Where(e => e.IsMandatory))
                anyCommandsWithSuboptions |= f.AddHelpRow(requiredParamsTable, ref requiredRow, applicationTr, helpProcessor);

            helpString.Add(ConsoleColoredString.NewLine);
            helpString.Add(new ConsoleColoredString(tr.ParametersHeader, CmdLineColor.HelpHeading));
            helpString.Add(ConsoleColoredString.NewLine);
            helpString.Add(ConsoleColoredString.NewLine);
            requiredParamsTable.RemoveEmptyColumns();
            helpString.Add(requiredParamsTable.ToColoredString());
        }

        // Table of optional parameters
        if (elements.Any(e => !e.IsMandatory))
        {
            var optionalParamsTable = new TextTable { MaxWidth = wrapToWidth - leftMargin, ColumnSpacing = 3, RowSpacing = 1, LeftMargin = leftMargin };
            int optionalRow = 0;
            foreach (var f in elements.Where(e => !e.IsMandatory))
                anyCommandsWithSuboptions |= f.AddHelpRow(optionalParamsTable, ref optionalRow, applicationTr, helpProcessor);

            helpString.Add(ConsoleColoredString.NewLine);
            helpString.Add(new ConsoleColoredString(tr.OptionsHeader, CmdLineColor.HelpHeading));
            helpString.Add(ConsoleColoredString.NewLine);
            helpString.Add(ConsoleColoredString.NewLine);
            optionalParamsTable.RemoveEmptyColumns();
            helpString.Add(optionalParamsTable.ToColoredString());
        }

        // “This command accepts further arguments on the command line.”
        if (anyCommandsWithSuboptions)
        {
            helpString.Add(ConsoleColoredString.NewLine);
            foreach (var line in (new ConsoleColoredString("* ", CmdLineColor.SubcommandsPresentAsterisk) + ConsoleColoredString.FromEggsNode(EggsML.Parse(tr.AdditionalOptions.Translation))).WordWrap(wrapToWidth, 2))
            {
                helpString.Add(line);
                helpString.Add(ConsoleColoredString.NewLine);
            }
        }

        return new ConsoleColoredString(helpString.ToArray());
    }

    #region Post-build step check

    /// <summary>
    ///     Performs safety checks to ensure that the structure of your command-line syntax defining class is valid according
    ///     to the criteria laid out in the documentation of <see cref="CommandLineParser"/>. Run this method as a post-build
    ///     step to ensure reliability of execution. For an example of use, see <see
    ///     cref="PostBuildChecker.RunPostBuildChecks"/>.</summary>
    /// <typeparam name="TArgs">
    ///     The class containing the fields and attributes which define the command-line syntax.</typeparam>
    /// <param name="rep">
    ///     Object to report post-build errors to.</param>
    /// <param name="applicationTrType">
    ///     The type of the translation object, derived from <see cref="TranslationBase"/>, which would be passed in for the
    ///     “applicationTr” parameter of <see cref="Parse"/> at normal run-time.</param>
    public static void PostBuildStep<TArgs>(IPostBuildReporter rep, Type applicationTrType)
    {
        var type = typeof(TArgs);
        if (!type.IsDefined<CommandLineAttribute>())
            rep.Error(@"To use {0} as a command-line type, it must have the [CommandLine] attribute.".Fmt(type.FullName), (type.IsEnum ? "enum " : type.IsInterface ? "interface " : typeof(Delegate).IsAssignableFrom(type) ? "delegate " : type.IsValueType ? "struct " : "class ") + type.Name);
        postBuildStep(rep, typeof(TArgs), applicationTrType, false);
    }

    private static void postBuildStep(IPostBuildReporter rep, Type cmdType, Type applicationTrType, bool classDocRecommended)
    {
        if (!cmdType.IsClass)
            rep.Error(@"{0} is not a class.".Fmt(cmdType.FullName), (cmdType.IsEnum ? "enum " : cmdType.IsInterface ? "interface " : typeof(Delegate).IsAssignableFrom(cmdType) ? "delegate " : "struct ") + cmdType.Name);

        object instance;
        var type = cmdType;
        try
        {
            if (type.IsAbstract)
                type = type.Assembly.GetTypes().FirstOrDefault(t => t.IsClass && !t.IsAbstract && cmdType.IsAssignableFrom(t) && t.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, null, Type.EmptyTypes, null) != null);
            if (type == null)
            {
                rep.Error(@"The class {0} does not have a derived non-abstract class type with a default constructor.".Fmt(cmdType.FullName), "class " + cmdType.Name);
                return;
            }
            instance = Activator.CreateInstance(type, true);
        }
        catch (Exception e)
        {
            rep.Error(@"{0} could not be instantiated ({1}). Does it have a default constructor?".Fmt(type.FullName, e.Message), "class " + type.Name);
            return;
        }

        if (applicationTrType != null)
        {
            Type[] typeParam;
            if (cmdType.TryGetGenericParameters(typeof(ICommandLineValidatable<>), out typeParam) && typeParam[0] != applicationTrType)
                rep.Error(@"The type {0} implements {1}, but the ApplicationTr type is {2}. If ApplicationTr is right, the interface implemented should be {3}.".Fmt(
                    cmdType.FullName,
                    typeof(ICommandLineValidatable<>).MakeGenericType(typeParam[0]).FullName,
                    applicationTrType.FullName,
                    typeof(ICommandLineValidatable<>).MakeGenericType(applicationTrType).FullName
                ), "class " + cmdType.Name);
        }

        var optionTaken = new Dictionary<string, MemberInfo>();
        var sensibleDocMethods = new List<MethodInfo>();
        FieldInfo lastField = null;
        bool haveSeenOptionalPositional = false;

        checkDocumentation(rep, cmdType, cmdType, applicationTrType, sensibleDocMethods, classDocRecommended);

        foreach (var field in getEligibleFields(cmdType))
        {
            if (field.IsDefined<IgnoreAttribute>())
                continue;

            // Every field must have one of the following
            var positional = field.IsDefined<IsPositionalAttribute>();
            var options = field.GetOrderedOptionAttributeNames();
            var enumOpt = field.GetCustomAttributes<EnumOptionsAttribute>().FirstOrDefault();

            if (positional && lastField != null)
                rep.Error(@"The type of {0}.{1} necessitates that no positional fields can follow it in the same class.".Fmt(lastField.DeclaringType.FullName, lastField.Name), "class " + cmdType.Name, field.Name);

            if (!positional && options == null && enumOpt == null)
            {
                rep.Error(@"{0}.{1}: Every field must have one of the following attributes: [IsPositional], [Option], [EnumOptions] (fields of an enum type only), or [Ignore].".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);
                continue;
            }

            // EnumOptionsAttribute can only be used on enum fields
            if (enumOpt != null && !field.FieldType.IsEnum)
                rep.Error(@"{0}.{1}: Cannot use [EnumOptions] attribute on a field whose type is not an enum type.".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);
            // Can’t combine IsPositional and Option
            else if (positional && options != null)
                rep.Error(@"{0}.{1}: Cannot use [IsPositional] and [Option] attributes on the same field.".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);
            // Can’t combine IsPositional and EnumOptions
            else if (positional && enumOpt != null)
                rep.Error(@"{0}.{1}: Cannot use [IsPositional] and [EnumOptions] attributes on the same field. For a positional enum value, use only [IsPositional].".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);
            // Can’t have [Option] without an option name
            else if (options != null && options.Length == 0)
                rep.Error(@"{0}.{1}: An [Option] attribute must specify at least one option name.".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);

            // Option names must start with a dash
            if (options != null && options.Any(o => !o.StartsWith('-')))
                rep.Error(@"{0}.{1}: All names in an [Option] attribute must start with at least one dash ('-'). Offending option name: ""{2}""".Fmt(field.DeclaringType.FullName, field.Name, options.First(o => !o.StartsWith('-'))), "class " + cmdType.Name, field.Name);

            var mandatory = field.IsDefined<IsMandatoryAttribute>();

            if (mandatory && field.IsDefined<UndocumentedAttribute>())
                rep.Error(@"{0}.{1}: Fields cannot simultaneously be mandatory and also undocumented.".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);

            if (positional && mandatory && haveSeenOptionalPositional)
                rep.Error(@"{0}.{1}: Positional fields can only be marked mandatory if all preceding positional fields are also marked mandatory.".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);
            else if (positional && !mandatory)
                haveSeenOptionalPositional = true;

            // ### ENUM fields
            if (field.FieldType.IsEnum)
            {
                // Can’t have a mandatory or a positional multi-value enum
                if (mandatory && enumOpt != null && enumOpt.Behavior == EnumBehavior.MultipleValues)
                    rep.Error(@"{0}.{1}: A mandatory enum field cannot use multi-value behavior.".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);
                if (positional && enumOpt != null && enumOpt.Behavior == EnumBehavior.MultipleValues)
                    rep.Error(@"{0}.{1}: A positional enum field cannot use multi-value behavior.".Fmt(field.DeclaringType.FullName, field.Name), "class " + cmdType.Name, field.Name);

                var commandsTaken = new Dictionary<string, FieldInfo>();
                var defaultValue = field.GetValue(instance);

                foreach (var enumField in field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
                {
                    if (enumField.IsDefined<IgnoreAttribute>())
                        continue;
                    // If the field is not mandatory, it is allowed to have a default value
                    if (!mandatory && enumField.GetValue(null).Equals(defaultValue))
                        continue;

                    // check that the enum values all have documentation
                    checkDocumentation(rep, enumField, cmdType, applicationTrType, sensibleDocMethods, true);

                    if (options != null || positional)
                    {
                        // check that the enum values all have at least one CommandName, and they do not clash
                        var cmdNames = enumField.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
                        if (cmdNames == null || cmdNames.Names.Length == 0)
                            rep.Error(@"{0}.{1} (used by {2}.{3}): Enum value must have a [CommandName] attribute (unless it is the field's default value and the field is optional).".Fmt(field.FieldType.FullName, enumField.Name, cmdType.FullName, field.Name), "enum " + field.FieldType.Name, enumField.Name);
                        else
                            checkCommandNamesUnique(rep, cmdNames.Names, commandsTaken, cmdType, field, enumField);
                    }
                    else
                    {
                        // check that the non-default enum values’ Options are present and do not clash
                        var optionNames = enumField.GetOrderedOptionAttributeNames();
                        if (optionNames == null || !optionNames.Any())
                            rep.Error(@"{0}.{1} (used by {2}.{3}): Enum value must have an [Option] attribute with at least one option name (unless it is the field's default value and the field is optional).".Fmt(field.FieldType.FullName, enumField.Name, cmdType.FullName, field.Name), "enum " + field.FieldType.Name, enumField.Name);
                        else
                            checkOptionsUnique(rep, optionNames, optionTaken, cmdType, field, enumField);
                    }
                }

                // If the enum field has an Option attribute, it needs documentation too
                if (options != null)
                    checkDocumentation(rep, field, cmdType, applicationTrType, sensibleDocMethods, true);
            }
            // ### BOOL fields
            else if (field.FieldType == typeof(bool))
            {
                if (positional || mandatory)
                    rep.Error(@"{0}.{1}: Fields of type bool cannot be positional or mandatory.".Fmt(cmdType.FullName, field.Name), "class " + cmdType.Name, field.Name);
                else
                    // Here we have checked that the field is not positional, not an enum, and not [Ignore]’d, so it must have an [Option] attribute
                    checkOptionsUnique(rep, options, optionTaken, cmdType, field);
                checkDocumentation(rep, field, cmdType, applicationTrType, sensibleDocMethods, true);
            }
            // ### STRING, STRING[], INTEGER and FLOATING fields (including nullable)
            else if (field.FieldType == typeof(string) || field.FieldType == typeof(string[]) ||
                (ExactConvert.IsTrueIntegerType(field.FieldType) && !field.FieldType.IsEnum) ||
                (ExactConvert.IsTrueIntegerNullableType(field.FieldType) && !field.FieldType.GetGenericArguments()[0].IsEnum) ||
                field.FieldType == typeof(float) || field.FieldType == typeof(float?) || field.FieldType == typeof(double) || field.FieldType == typeof(double?))
            {
                // options is null if and only if this field is positional
                if (options != null)
                    checkOptionsUnique(rep, options, optionTaken, cmdType, field);
                checkDocumentation(rep, field, cmdType, applicationTrType, sensibleDocMethods, true);

                // A positional string[] can only be the last field
                if (positional && field.FieldType == typeof(string[]))
                    lastField = field;
            }
            else
                rep.Error(@"{0}.{1} is not of a supported type. Currently accepted types are: enum types, bool, string, string[], numeric types (byte, sbyte, short, ushort, int, uint, long, ulong, float and double) and nullable numeric types.".Fmt(cmdType.FullName, field.Name), "class " + cmdType.Name, field.Name);
        }

        // Check for derived classes
        var subcommandsTaken = new Dictionary<string, Type>();
        var anyDerived = false;
        foreach (var derivedType in getDirectSubcommands(cmdType))
        {
            anyDerived = true;
            checkCommandNamesUnique(rep, derivedType.GetCustomAttributes<CommandNameAttribute>().First().Names, subcommandsTaken, derivedType);
            postBuildStep(rep, derivedType, applicationTrType, true);
        }

        if (anyDerived && lastField != null)
            rep.Error(@"The type of {0}.{1} precludes the use of subcommands.".Fmt(lastField.DeclaringType.FullName, lastField.Name), "class " + cmdType.Name, lastField.Name);

        if (applicationTrType != null)
            // Warn if the class has unused documentation methods
            foreach (var meth in cmdType.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).Where(m => m.Name.EndsWith("Doc") && m.ReturnType == typeof(string) && m.GetParameters().Select(p => p.ParameterType).SequenceEqual(new Type[] { applicationTrType })))
                if (!sensibleDocMethods.Contains(meth))
                    rep.Error(@"{0}.{1} looks like a documentation method, but has no corresponding field, or the corresponding field does not require documentation because it is a positional enum or has an [EnumOptions] attribute.".Fmt(cmdType.FullName, meth.Name), "class " + cmdType.Name, meth.Name);
    }

    private static void checkOptionsUnique(IPostBuildReporter rep, IEnumerable<string> options, Dictionary<string, MemberInfo> optionTaken, Type type, FieldInfo field, FieldInfo enumField)
    {
        foreach (var option in options)
        {
            if (optionTaken.ContainsKey(option))
            {
                rep.Error(@"{0}.{1}: Option ""{2}"" is used more than once.".Fmt(field.FieldType.FullName, enumField.Name, option), "enum " + field.FieldType.Name, enumField.Name);
                rep.Error(@" -- It is used by {0}.{1}...".Fmt(type.FullName, field.Name), "class " + type.Name, field.Name);
                rep.Error(@" -- ... and by {0}.{1}.".Fmt(optionTaken[option].DeclaringType.FullName, optionTaken[option].Name), "class " + optionTaken[option].DeclaringType.Name, optionTaken[option].Name);
            }
            optionTaken[option] = field;
        }
    }

    private static void checkOptionsUnique(IPostBuildReporter rep, IEnumerable<string> options, Dictionary<string, MemberInfo> optionTaken, Type type, FieldInfo field)
    {
        foreach (var option in options)
        {
            if (optionTaken.ContainsKey(option))
            {
                rep.Error(@"Option ""{2}"" is used by {0}.{1}...".Fmt(type.FullName, field.Name, option), "class " + type.Name, field.Name);
                rep.Error(@" -- ... and by {0}.{1}.".Fmt(optionTaken[option].DeclaringType.FullName, optionTaken[option].Name), "class " + optionTaken[option].DeclaringType.Name, optionTaken[option].Name);
            }
            optionTaken[option] = field;
        }
    }

    private static void checkCommandNamesUnique(IPostBuildReporter rep, string[] commandNames, Dictionary<string, Type> commandsTaken, Type subclass)
    {
        foreach (var cmd in commandNames)
        {
            if (commandsTaken.ContainsKey(cmd))
            {
                rep.Error(@"CommandName ""{1}"" is used by {0}...".Fmt(subclass.FullName, cmd), "class " + subclass.Name);
                rep.Error(@" -- ... and by {0}.".Fmt(commandsTaken[cmd].FullName), "class " + commandsTaken[cmd].Name);
            }
            commandsTaken[cmd] = subclass;
        }
    }

    private static void checkCommandNamesUnique(IPostBuildReporter rep, string[] commandNames, Dictionary<string, FieldInfo> commandsTaken, Type type, FieldInfo field, FieldInfo enumField)
    {
        foreach (var cmd in commandNames)
        {
            if (commandsTaken.ContainsKey(cmd))
            {
                rep.Error(@"{0}.{1}: Option ""{2}"" is used more than once.".Fmt(field.FieldType.FullName, enumField.Name, cmd), "enum " + field.FieldType.Name, enumField.Name);
                rep.Error(@" -- It is used by {0}.{1}...".Fmt(type.FullName, field.Name), "class " + type.Name, field.Name);
                rep.Error(@" -- ... and by {0}.{1}.".Fmt(commandsTaken[cmd].DeclaringType.FullName, commandsTaken[cmd].Name), "class " + commandsTaken[cmd].DeclaringType.Name, commandsTaken[cmd].Name);
            }
            commandsTaken[cmd] = enumField;
        }
    }

    private static Dictionary<Type, object> _applicationTrCacheField = null;
    private static Dictionary<Type, object> _applicationTrCache
    {
        get
        {
            if (_applicationTrCacheField == null)
                _applicationTrCacheField = new Dictionary<Type, object>();
            return _applicationTrCacheField;
        }
    }

    private static void checkDocumentation(IPostBuildReporter rep, MemberInfo member, Type inType, Type applicationTrType, List<MethodInfo> sensibleDocMethods, bool classDocRecommended)
    {
        if (member.IsDefined<UndocumentedAttribute>())
            return;

        if (!(member is Type) && inType.IsSubclassOf(member.DeclaringType))
            inType = member.DeclaringType;

        var attr = member.GetCustomAttributes<DocumentationAttribute>().FirstOrDefault();
        ConsoleColoredString toCheck = null;
        if (attr != null)
        {
            try
            {
                toCheck = attr.Text; // this property can throw the first time it's accessed
            }
            catch (Exception e)
            {
                if (member is Type)
                    rep.Error(@"{0}: Type documentation could not be parsed as {1}: {2}".Fmt(((Type) member).FullName, attr.OriginalFormat, e.Message), "class " + member.Name);
                else
                    rep.Error(@"{0}.{1}: Field documentation could not be parsed as {2}: {3}".Fmt(member.DeclaringType.FullName, member.Name, attr.OriginalFormat, e.Message), "class " + member.DeclaringType.Name, member.Name);
                return;
            }
        }
        else if (applicationTrType != null)
        {
            var meth = inType.GetMethod(member.Name + "Doc", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { applicationTrType }, null);
            if (meth != null && meth.ReturnType == typeof(string))
            {
                sensibleDocMethods.Add(meth);
                if (!_applicationTrCache.ContainsKey(applicationTrType))
                    _applicationTrCache[applicationTrType] = Activator.CreateInstance(applicationTrType);
                var appTr = _applicationTrCache[applicationTrType];
                toCheck = (string) meth.Invoke(null, new object[] { appTr });
                if (toCheck == null)
                {
                    rep.Error(@"{0}." + member.Name + @"Doc() returned null.".Fmt(inType.FullName), "class " + inType.Name, member.Name + "Doc");
                    return;
                }
            }
        }

        if (classDocRecommended && toCheck == null)
        {
            if (member is Type)
            {
                rep.Warning((@"{0} does not have any documentation. " +
                    (applicationTrType == null ? "U" : @"To provide localised documentation, declare a method ""static string {1}Doc({2})"" on {3}. Otherwise, u") +
                    @"se the [DocumentationLiteral] attribute to specify unlocalisable documentation. " +
                    @"Use [Undocumented] to completely hide an option or command from the help screen.").Fmt(((Type) member).FullName, member.Name, applicationTrType != null ? applicationTrType.FullName : null, inType.FullName),
                    ((Type) member).Namespace,
                    "CommandName",
                    "class " + member.Name);
            }
            else
            {
                rep.Warning((@"{0}.{1} does not have any documentation. " +
                    (applicationTrType == null ? "U" : @"To provide localised documentation, declare a method ""static string {1}Doc({2})"" on {3}. Otherwise, u") +
                    @"se the [DocumentationLiteral] attribute to specify unlocalisable documentation. " +
                    @"Use [Undocumented] to completely hide an option or command from the help screen.").Fmt(member.DeclaringType.FullName, member.Name, applicationTrType != null ? applicationTrType.FullName : null, inType.FullName),
                    member.DeclaringType.Namespace,
                    (member.DeclaringType.IsEnum ? "enum " : member.DeclaringType.IsValueType ? "struct " : "class ") + member.DeclaringType.Name,
                    member.Name);
            }
            return;
        }
    }

    #endregion

    /// <summary>
    ///     Converts the specified <see cref="RhoML"/> parse tree into a console colored string according to
    ///     CommandLineParser-specific rules. This method is used to convert <see cref="DocumentationRhoMLAttribute"/>
    ///     documentation into colored text. See Remarks.</summary>
    /// <remarks>
    ///     A number of named tags have a special meaning. Any tag named after a value of <see cref="ConsoleColor"/> results
    ///     in that color. Both spellings of gray/grey are supported. The {h}...{} named tag stands for the highlight color
    ///     (white). {nowrap}...{} can be placed around text that must not be broken into multiple lines by the word wrapper.
    ///     The tags {field}, {option}, {command} and {enum} are used to refer to the corresponding command line syntax
    ///     element, and is highlighted the same way the documentation generator would highlight references to these entities.</remarks>
    public static ConsoleColoredString Colorize(RhoElement text)
    {
        var strings = new List<ConsoleColoredString>();
        if (text.Name == null)
            colorizeChildren(text, strings, ConsoleColor.Gray, false);
        else
            colorizeWalk(text, strings, ConsoleColor.Gray, false);
        return new ConsoleColoredString(strings);
    }

    /// <summary>
    ///     Converts the specified <see cref="EggsML"/> parse tree into a console colored string using the rules described in
    ///     <see cref="EggsNode.ToConsoleColoredStringWordWrap"/>. This method is used to convert <see
    ///     cref="DocumentationEggsMLAttribute"/> documentation into colored text, as well as any documentation using the
    ///     legacy <see cref="DocumentationLiteralAttribute"/>.</summary>
    public static ConsoleColoredString Colorize(EggsNode text)
    {
        return text.ToConsoleColoredStringWordWrap(int.MaxValue).JoinColoredString(Environment.NewLine);
    }

    private static void colorizeChildren(RhoElement text, List<ConsoleColoredString> strings, ConsoleColor curColor, bool curNowrap)
    {
        foreach (var child in text.Children)
        {
            if (child is RhoText)
                strings.Add(nowrap((child as RhoText).Text, curNowrap).Color(curColor));
            else
                colorizeWalk(child as RhoElement, strings, curColor, curNowrap);
        }
    }

    private static void colorizeWalk(RhoElement text, List<ConsoleColoredString> strings, ConsoleColor curColor, bool curNowrap)
    {
        var name = text.Name.ToLower();
        if (name == "field")
        {
            validateNoAttributes(text);
            validateOnlyTextChild(text);
            strings.Add("<".Color(CmdLineColor.FieldBrackets) + nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }
        else if (name == "option")
        {
            validateNoAttributes(text);
            validateOnlyTextChild(text);
            strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Option));
        }
        else if (name == "command")
        {
            validateNoAttributes(text);
            validateOnlyTextChild(text);
            strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.Command));
        }
        else if (name == "enum")
        {
            validateNoAttributes(text);
            validateOnlyTextChild(text);
            strings.Add(nowrap((text.Children[0] as RhoText).Text).Color(CmdLineColor.EnumValue));
        }
        else if (name == "nowrap")
        {
            validateNoAttributes(text);
            colorizeChildren(text, strings, curColor, true);
        }
        else if (name == "n") // newline
        {
            validateNoAttributes(text);
            validateNoChildren(text);
            strings.Add("\n");
        }
        else if (name == "h") // highlight
        {
            validateNoAttributes(text);
            colorizeChildren(text, strings, CmdLineColor.Highlight, curNowrap);
        }
        else
        {
            if (!EnumStrong.TryParse<ConsoleColor>(name, out curColor, true))
            {
                if (name == "grey")
                    curColor = ConsoleColor.Gray;
                else if (name == "darkgrey")
                    curColor = ConsoleColor.DarkGray;
                else
                    throw new ArgumentException("Unsupported element: {0}.".Fmt(text.Name), "text");
            }
            validateNoAttributes(text);
            colorizeChildren(text, strings, curColor, curNowrap);
        }
    }

    private static string nowrap(string text, bool doNowrap = true)
    {
        if (doNowrap)
            return text.Replace(' ', '\xA0'); // non-breaking space
        else
            return text;
    }

    private static void validateNoAttributes(RhoElement text)
    {
        if (text.Value != null || text.Attributes.Any())
            throw new ArgumentException("Element {0} must not have any attributes.".Fmt(text.Name), "text");
    }

    private static void validateNoChildren(RhoElement text)
    {
        if (text.Children.Any())
            throw new ArgumentException("Element {0} must not have any child nodes.".Fmt(text.Name), "text");
    }

    private static void validateOnlyTextChild(RhoElement text)
    {
        if (text.Children.Count != 1 || !(text.Children[0] is RhoText))
            throw new ArgumentException("Element {0} must only contain text, and no other elements.".Fmt(text.Name), "text");
    }
}

internal class CommandInfo
{
    public Type Type;
    public CmdLineElement[] Elements;
}

internal sealed class SubcommandInfo : CommandInfo
{
    public string[] Names;
}

internal abstract class CmdLineElement : IComparable<CmdLineElement>
{
    public bool IsMandatory;
    public virtual bool IsPositional { get { return false; } }
    public abstract bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd);
    public abstract void ProcessEndOfParameters(List<Action<object>> actionsToPerform, CommandInfo cmd);
    public abstract ConsoleColoredString UsageString { get; }
    public abstract bool AddHelpRow(TextTable table, ref int row, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor);

    public int CompareTo(CmdLineElement other)
    {
        // Options must be listed before positionals because if a positional is a subcommand, all the options must be before it.
        if (IsPositional && !other.IsPositional)
            return 1;
        if (!IsPositional && other.IsPositional)
            return -1;

        // Optional positionals must come after mandatory positionals because that is the order they must be specified in.
        // If any mandatory positional is a subcommand, then you can’t have any optional positionals anyway.
        if (IsMandatory && !other.IsMandatory)
            return -1;
        if (!IsMandatory && other.IsMandatory)
            return 1;

        return 0;
    }

    protected ConsoleColoredString FormatField(string name)
    {
        return "<".Color(CmdLineColor.FieldBrackets) + name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets);
    }

    protected static bool tryConvertString(string value, List<Action<object>> listToAddActionTo, FieldInfo field)
    {
        object result;

        if (field.FieldType == typeof(string))
            result = value;
        else
        {
            Type type = field.FieldType.IsGenericType && field.FieldType.GetGenericTypeDefinition() == typeof(Nullable<>)
                ? field.FieldType.GetGenericArguments()[0]
                : field.FieldType;
            if (!ExactConvert.Try(type, value, out result))
                return false;
        }
        listToAddActionTo.Add(obj => { field.SetValue(obj, result); });
        return true;
    }
}

internal abstract class CmdLineFieldPositional : CmdLineElement
{
    public override bool IsPositional { get { return true; } }

    public FieldInfo Field;
    public override void ProcessEndOfParameters(List<Action<object>> actionsToPerform, CommandInfo cmd)
    {
        if (IsMandatory)
            throw new MissingParameterException(Field, null, false, cmd);
    }
    public override ConsoleColoredString UsageString
    {
        get
        {
            return (IsMandatory ? "{0}" : "[{0}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                "<".Color(CmdLineColor.FieldBrackets) + Field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }
    }
    public override bool AddHelpRow(TextTable table, ref int row, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        table.SetCell(0, row, FormatField(Field.Name), noWrap: true, colSpan: 2);
        table.SetCell(2, row, Field.GetDocumentation(Field.DeclaringType, applicationTr, helpProcessor), colSpan: 4);
        row++;
        return false;
    }
}

internal sealed class CmdLineEnumFieldPositional : CmdLineFieldPositional
{
    public override bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd)
    {
        var name = args[i];
        if (name.StartsWith('-') && !suppressOptions)
            return false;
        foreach (var enumField in Field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
        {
            if (enumField.GetCustomAttributes<CommandNameAttribute>().First().Names.Any(c => c.Equals(name, StringComparison.OrdinalIgnoreCase)))
            {
                actionsToPerform.Add(obj => { Field.SetValue(obj, enumField.GetValue(null)); });
                i++;
                return true;
            }
        }
        throw new UnrecognizedCommandOrOptionException(args[i], cmd);
    }

    public override bool AddHelpRow(TextTable table, ref int row, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        var topRow = row;
        var doc = Field.GetDocumentation(Field.DeclaringType, applicationTr, helpProcessor);
        if (doc.Length > 0 || Field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).All(el => el.IsDefined<UndocumentedAttribute>() || !el.GetCustomAttributes<CommandNameAttribute>().Any()))
        {
            table.SetCell(2, row, doc, colSpan: 4);
            row++;
        }
        foreach (var el in Field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public))
        {
            if (el.IsDefined<UndocumentedAttribute>())
                continue;
            var attr = el.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
            if (attr == null)   // skip the default value
                continue;
            table.SetCell(2, row, attr.Names.Where(n => n.Length <= 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(", "), noWrap: true);
            table.SetCell(3, row, attr.Names.Where(n => n.Length > 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(Environment.NewLine), noWrap: true);
            table.SetCell(4, row, el.GetDocumentation(Field.DeclaringType, applicationTr, helpProcessor), colSpan: 2);
            row++;
        }
        table.SetCell(0, topRow, FormatField(Field.Name), noWrap: true, colSpan: 2, rowSpan: row - topRow);
        return false;
    }
}

internal abstract class CmdLineOption : CmdLineElement
{
    public string[] Options;
}

internal abstract class CmdLineFieldOption : CmdLineOption
{
    public FieldInfo Field;

    public override void ProcessEndOfParameters(List<Action<object>> actionsToPerform, CommandInfo cmd)
    {
        if (IsMandatory)
            throw new MissingParameterException(Field, null, true, cmd);
    }

    public override bool AddHelpRow(TextTable table, ref int row, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        table.SetCell(0, row, Field.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true);
        table.SetCell(1, row, Field.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true);
        table.SetCell(2, row, Field.GetDocumentation(Field.DeclaringType, applicationTr, helpProcessor), colSpan: 4);
        row++;
        return false;
    }
}

internal abstract class CmdLineEnumOption : CmdLineFieldOption
{
    public EnumBehavior Behavior;
    public string AlreadyProcessedOptionOrCommand = null;
    public object AlreadyProcessedValue = null;

    protected abstract object getValue(string[] args, ref int i, out string optionOrCommand, CommandInfo cmd);

    public override bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd)
    {
        if (suppressOptions || !Options.Contains(args[i]))
            return false;
        string optionOrCommand;
        var value = getValue(args, ref i, out optionOrCommand, cmd);
        if (value == null)
            return false;
        if (Behavior == EnumBehavior.SingleValue)
        {
            if (AlreadyProcessedOptionOrCommand == null)
            {
                AlreadyProcessedOptionOrCommand = optionOrCommand;
                AlreadyProcessedValue = value;
                actionsToPerform.Add(obj => { Field.SetValue(obj, value); });
            }
            else if (AlreadyProcessedValue.Equals(value))
            {
                // Don’t throw an error if the same value is simply specified multiple times. Just ignore the second occurrence
            }
            else
            {
                // Since only a single value is allowed, throw an error if another value is specified later
                throw new IncompatibleCommandOrOptionException(AlreadyProcessedOptionOrCommand, optionOrCommand, cmd);
            }
        }
        else
        {
            if (AlreadyProcessedValue == null)
                AlreadyProcessedValue = value;
            else
                // Bitwise OR
                value = AlreadyProcessedValue = (dynamic) AlreadyProcessedValue | (dynamic) value;

            actionsToPerform.Add(obj => { Field.SetValue(obj, value); });
        }
        return true;
    }
}

internal sealed class CmdLineEnumOptionWithNames : CmdLineEnumOption
{
    public Dictionary<string, object> NameToValue;

    protected override object getValue(string[] args, ref int i, out string optionOrCommand, CommandInfo cmd)
    {
        i++;
        if (i >= args.Length)
            throw new IncompleteOptionException(args[i - 1], cmd);
        optionOrCommand = args[i];
        object value;
        if (!NameToValue.TryGetValue(optionOrCommand, out value))
            throw new UnrecognizedCommandOrOptionException(optionOrCommand, cmd);
        i++;
        return value;
    }

    public override ConsoleColoredString UsageString
    {
        get
        {
            if (Behavior == EnumBehavior.MultipleValues)
            {
                // -t name [-t name [...]]    — multi-value enums with CommandNames
                return (IsMandatory ? "{0} {1} [{0} {1} [...]]" : "[{0} {1} [{0} {1} [...]]]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                    Options[0].Color(CmdLineColor.Option),
                    "<".Color(CmdLineColor.FieldBrackets) + Field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
            }
            else
            {
                // -t name
                return (IsMandatory ? "{0} {1}" : "[{0} {1}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                    Options[0].Color(CmdLineColor.Option),
                    "<".Color(CmdLineColor.FieldBrackets) + Field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
            }
        }
    }

    public override bool AddHelpRow(TextTable table, ref int row, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        var topRow = row;
        row++;
        foreach (var el in Field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).Where(e => !e.IsDefined<UndocumentedAttribute>()))
        {
            var attr = el.GetCustomAttributes<CommandNameAttribute>().FirstOrDefault();
            if (attr == null)   // skip the default value
                continue;
            table.SetCell(3, row, attr.Names.Where(n => n.Length <= 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(", "), noWrap: true);
            table.SetCell(4, row, attr.Names.Where(n => n.Length > 2).Select(s => s.Color(CmdLineColor.EnumValue)).JoinColoredString(Environment.NewLine), noWrap: true);
            table.SetCell(5, row, el.GetDocumentation(Field.DeclaringType, applicationTr, helpProcessor));
            row++;
        }
        if (row == topRow + 1)
            throw new InvalidOperationException("Enum type {2}.{3} has no values (apart from default value for field {0}.{1}).".Fmt(Field.DeclaringType.FullName, Field.Name, Field.FieldType.DeclaringType.FullName, Field.FieldType));
        table.SetCell(0, topRow, Field.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true, rowSpan: row - topRow);
        table.SetCell(1, topRow, Field.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true, rowSpan: row - topRow);
        table.SetCell(2, topRow, Field.GetDocumentation(Field.DeclaringType, applicationTr, helpProcessor), colSpan: 4);
        table.SetCell(2, topRow + 1, FormatField(Field.Name), noWrap: true, rowSpan: row - topRow - 1);
        return false;
    }
}

internal sealed class CmdLineEnumOptions : CmdLineEnumOption
{
    public Dictionary<string, object> OptionToValue;

    protected override object getValue(string[] args, ref int i, out string optionOrCommand, CommandInfo cmd)
    {
        optionOrCommand = args[i];
        i++;
        return OptionToValue[optionOrCommand];
    }

    public override ConsoleColoredString UsageString
    {
        get
        {
            var options = Field.FieldType.GetFields(BindingFlags.Public | BindingFlags.Static)
                .Where(fld => fld.IsDefined<OptionAttribute>() && !fld.IsDefined<UndocumentedAttribute>())
                .Select(fi => fi.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option))
                .ToArray();

            if (Behavior == EnumBehavior.MultipleValues)
                // [-t] [-u] [-v]    — multi-value enums with Option names
                return options.Select(opt => "[{0}]".Color(CmdLineColor.OptionalityDelimiters).Fmt(opt)).JoinColoredString(" ");

            // {-t|-u}      — single-value enums with Options
            return (IsMandatory ? (options.Length > 1 ? "{{{0}{1}" : "{0}") : "[{0}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(options.JoinColoredString("|".Color(CmdLineColor.OptionalityDelimiters)), "}");
        }
    }

    public override bool AddHelpRow(TextTable table, ref int row, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        foreach (var el in Field.FieldType.GetFields(BindingFlags.Static | BindingFlags.Public).Where(e => e.IsDefined<OptionAttribute>() && !e.IsDefined<UndocumentedAttribute>()))
        {
            table.SetCell(0, row, el.GetOrderedOptionAttributeNames().Where(o => !o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(", "), noWrap: true);
            table.SetCell(1, row, el.GetOrderedOptionAttributeNames().Where(o => o.StartsWith("--")).OrderBy(cmd => cmd.Length).Select(cmd => cmd.Color(CmdLineColor.Option)).JoinColoredString(Environment.NewLine), noWrap: true);
            table.SetCell(2, row, el.GetDocumentation(Field.DeclaringType, applicationTr, helpProcessor), colSpan: 4);
            row++;
        }
        return false;
    }
}

internal sealed class CmdLineBoolOption : CmdLineFieldOption
{
    public override bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd)
    {
        if (suppressOptions || !Options.Contains(args[i]))
            return false;
        actionsToPerform.Add(obj => { Field.SetValue(obj, true); });
        i++;
        return true;
    }

    public override ConsoleColoredString UsageString
    {
        get
        {
            // [-t]
            return "[{0}]".Color(CmdLineColor.OptionalityDelimiters).Fmt(Field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option));
        }
    }
}

// Covers string, integers, float/double, and their nullables
internal sealed class CmdLineOtherOption : CmdLineFieldOption
{
    public override bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd)
    {
        var optionName = args[i];
        if (suppressOptions || !Options.Contains(optionName))
            return false;

        i++;
        if (i >= args.Length)
            throw new IncompleteOptionException(optionName, cmd);

        if (!tryConvertString(args[i], actionsToPerform, Field))
            throw new InvalidNumericParameterException(Field.Name, cmd);

        i++;
        return true;
    }

    public override ConsoleColoredString UsageString
    {
        get
        {
            // -t name
            return (IsMandatory ? "{0} {1}" : "[{0} {1}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                Field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option),
                "<".Color(CmdLineColor.FieldBrackets) + Field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }
    }
}

// Covers string, integers, float/double, and their nullables
internal sealed class CmdLineOtherPositional : CmdLineFieldPositional
{
    public override bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd)
    {
        if (!tryConvertString(args[i], actionsToPerform, Field))
            throw new InvalidNumericParameterException(Field.Name, cmd);
        i++;
        return true;
    }
}

internal sealed class CmdLineStringArrayOption : CmdLineFieldOption
{
    private bool Already = false;
    public override bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd)
    {
        var optionName = args[i];
        if (suppressOptions || !Options.Contains(optionName))
            return false;

        i++;
        if (i >= args.Length)
            throw new IncompleteOptionException(optionName, cmd);

        var value = args[i];
        if (Already)
            actionsToPerform.Add(obj => { Field.SetValue(obj, ((string[]) Field.GetValue(obj)).Concat(value).ToArray()); });
        else
        {
            actionsToPerform.Add(obj => { Field.SetValue(obj, new string[] { value }); });
            Already = true;
        }

        i++;
        return true;
    }

    public override ConsoleColoredString UsageString
    {
        get
        {
            // -t name [-t name [...]]
            return (IsMandatory ? "{0} {1} [{0} {1} [...]]" : "[{0} {1} [{0} {1} [...]]]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                Field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option),
                "<".Color(CmdLineColor.FieldBrackets) + Field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }
    }
}

internal sealed class CmdLineStringArrayPositional : CmdLineFieldPositional
{
    private List<string> Already = null;

    public override bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd)
    {
        if (Already == null)
            Already = new List<string>();
        Already.Add(args[i]);
        i++;
        return true;
    }

    public override void ProcessEndOfParameters(List<Action<object>> actionsToPerform, CommandInfo cmd)
    {
        if (IsMandatory && Already == null)
            throw new MissingParameterException(Field, null, false, cmd);
        actionsToPerform.Add(obj => { Field.SetValue(obj, Already == null ? new string[] { } : Already.ToArray()); });
    }
}

internal sealed class CmdLineSubcommand : CmdLineElement
{
    public override bool IsPositional { get { return true; } }

    public Type Type;
    public SubcommandInfo[] Subcommands;
    public SubcommandInfo Subcommand;

    public override bool ProcessParameter(string[] args, ref int i, List<Action<object>> actionsToPerform, bool suppressOptions, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor, CommandInfo cmd)
    {
        var name = args[i];
        Subcommand = Subcommands.FirstOrDefault(s => s.Names.Contains(name));
        if (Subcommand == null)
            throw new UnrecognizedCommandOrOptionException(name, cmd);
        i++;
        return true;
    }

    public override void ProcessEndOfParameters(List<Action<object>> actionsToPerform, CommandInfo cmd)
    {
        if (IsMandatory)
            throw new MissingSubcommandException(cmd);
    }

    public override ConsoleColoredString UsageString
    {
        get
        {
            return (IsMandatory ? "{0}" : "[{0}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                "<".Color(CmdLineColor.FieldBrackets) + "...".Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }
    }

    public override bool AddHelpRow(TextTable table, ref int row, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        var anyCommandsWithSuboptions = false;
        int origRow = row;
        foreach (var subcmd in Subcommands)
        {
            var cell1 = ConsoleColoredString.Empty;
            var cell2 = ConsoleColoredString.Empty;
            anyCommandsWithSuboptions |= subcmd.Elements.Length > 0;
            var asterisk = subcmd.Elements.Length > 0 ? "*".Color(CmdLineColor.SubcommandsPresentAsterisk) : ConsoleColoredString.Empty;
            table.SetCell(2, row, subcmd.Names.Where(n => n.Length <= 2).Select(n => n.Color(CmdLineColor.Command) + asterisk).JoinColoredString(", "), noWrap: true);
            table.SetCell(3, row, subcmd.Names.Where(n => n.Length > 2).Select(n => n.Color(CmdLineColor.Command) + asterisk).JoinColoredString(Environment.NewLine), noWrap: true);
            table.SetCell(4, row, subcmd.Type.GetDocumentation(subcmd.Type, applicationTr, helpProcessor), colSpan: 2);
            row++;
        }
        table.SetCell(0, origRow, FormatField("..."), colSpan: 2, rowSpan: row - origRow, noWrap: true);
        return anyCommandsWithSuboptions;
    }
}

internal static class CmdLineColor
{
    public const ConsoleColor Option = ConsoleColor.Yellow;
    public const ConsoleColor FieldBrackets = ConsoleColor.DarkCyan;
    public const ConsoleColor Field = ConsoleColor.Cyan;
    public const ConsoleColor Command = ConsoleColor.Green;
    public const ConsoleColor EnumValue = ConsoleColor.Green;
    public const ConsoleColor UsageLinePrefix = ConsoleColor.Green;
    public const ConsoleColor OptionalityDelimiters = ConsoleColor.DarkGray; // e.g. [foo|bar] has [, ] and | in this color
    public const ConsoleColor SubcommandsPresentAsterisk = ConsoleColor.DarkYellow;
    public const ConsoleColor UnexpectedArgument = ConsoleColor.Magenta;
    public const ConsoleColor Error = ConsoleColor.Red;
    public const ConsoleColor HelpHeading = ConsoleColor.White;
    public const ConsoleColor Highlight = ConsoleColor.White;
}

/// <summary>
///     Contains methods to validate a set of parameters passed by the user on the command-line and parsed by <see
///     cref="CommandLineParser"/>. Use this class only in monolingual (unlocalisable) applications. Use <see
///     cref="ICommandLineValidatable{TTranslation}"/> otherwise.</summary>
public interface ICommandLineValidatable
{
    /// <summary>
    ///     When overridden in a derived class, returns an error message if the contents of the class are invalid, otherwise
    ///     returns null.</summary>
    ConsoleColoredString Validate();
}

/// <summary>
///     Contains methods to validate a set of parameters passed by the user on the command-line and parsed by <see
///     cref="CommandLineParser"/>.</summary>
/// <typeparam name="TTranslation">
///     A translation-string class containing the error messages that can occur during validation.</typeparam>
public interface ICommandLineValidatable<in TTranslation> where TTranslation : TranslationBase
{
    /// <summary>
    ///     When implemented in a class, returns an error message if the contents of the class are invalid, otherwise returns
    ///     null.</summary>
    /// <param name="tr">
    ///     Contains translations for the messages that may occur during validation.</param>
    ConsoleColoredString Validate(TTranslation tr);
}

/// <summary>Groups the translatable strings in the <see cref="Translation"/> class into categories.</summary>
public enum TranslationGroup
{
    /// <summary>Error messages produced by the command-line parser.</summary>
    [LingoGroup("Command-line errors", "Contains messages informing the user of invalid command-line syntax.")]
    CommandLineError,
    /// <summary>Messages used by the command-line parser to produce help pages.</summary>
    [LingoGroup("Command-line help", "Contains messages used to construct help pages for command-line options and parameters.")]
    CommandLineHelp
}

/// <summary>Contains translatable strings pertaining to the command-line parser, including error messages and usage help.</summary>
public sealed class Translation : TranslationBase
{
#pragma warning disable 1591    // Missing XML comment for publicly visible type or member
    public Translation() : base(Language.EnglishUS) { }

    [LingoInGroup(TranslationGroup.CommandLineError)]
    public TrString
        IncompatibleCommandOrOption = @"The command or option, {0}, cannot be used in conjunction with {1}. Please specify only one of the two.",
        IncompleteOption = @"The {0} option must be followed by an additional parameter.",
        InvalidNumber = @"The {0} option expects a number. The specified parameter does not constitute a valid number.",
        MissingOption = @"The option {0} is mandatory and must be specified.",
        MissingOptionBefore = @"The option {0} is mandatory and must be specified before the {1} parameter.",
        MissingParameter = @"The parameter {0} is mandatory and must be specified.",
        MissingParameterBefore = @"The parameter {0} is mandatory and must be specified before the {1} parameter.",
        MissingSubcommand = @"The command line options must be followed by a command name.",
        UnexpectedParameter = @"Unexpected parameter: {0}",
        UnrecognizedCommandOrOption = @"The specified command or option, {0}, is not recognized.",
        UserRequestedHelp = @"The user has requested help using one of the help options.";

    [LingoInGroup(TranslationGroup.CommandLineHelp)]
    public TrString
        AdditionalOptions = @"This command accepts further arguments on the command line. Type the command followed by *-?* or *help* to list them.",
        Error = @"Error:",
        OptionsHeader = @"Optional parameters:",
        ParametersHeader = @"Required parameters:",
        Usage = @"Usage:";

#pragma warning restore 1591    // Missing XML comment for publicly visible type or member
}

/// <summary>Use this on a class to specify that it represent a command-line syntax.</summary>
[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public sealed class CommandLineAttribute : Attribute
{
    /// <summary>Constructor.</summary>
    public CommandLineAttribute() { }
}

/// <summary>
///     Use this on a derived class or on an enum value to specify the command the user must use to invoke that class or enum
///     value.</summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
public sealed class CommandNameAttribute : Attribute
{
    /// <summary>
    ///     Constructor.</summary>
    /// <param name="names">
    ///     The command(s) the user can specify to invoke this class or enum value.</param>
    public CommandNameAttribute(params string[] names) { Names = names; }
    /// <summary>The command the user can specify to invoke this class.</summary>
    public string[] Names { get; private set; }
}

/// <summary>Use this to specify that a command-line parameter is mandatory.</summary>
[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
public sealed class IsMandatoryAttribute : Attribute
{
    /// <summary>Constructor.</summary>
    public IsMandatoryAttribute() { }
}

/// <summary>
///     Use this to specify that a command-line parameter is positional, i.e. is not invoked by an option that starts with
///     "-".</summary>
[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
public sealed class IsPositionalAttribute : Attribute
{
    /// <summary>Constructor.</summary>
    public IsPositionalAttribute() { }
}

/// <summary>
///     Use this to specify that a field in a class can be specified on the command line using an option, for example
///     <c>-a</c> or <c>--option-name</c>. The option name(s) MUST begin with a dash (<c>-</c>).</summary>
[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
public sealed class OptionAttribute : Attribute
{
    /// <summary>
    ///     Constructor.</summary>
    /// <param name="names">
    ///     The name of the option. Specify several names as synonyms if required.</param>
    public OptionAttribute(params string[] names) { Names = names; }
    /// <summary>All of the names of the option.</summary>
    public string[] Names { get; private set; }
}

/// <summary>
///     Use this attribute to link a command-line option or command with the help text that describes (documents) it. Suitable
///     for single-language applications only. See Remarks.</summary>
/// <remarks>
///     This attribute specifies the documentation in plain text. All characters are printed exactly as specified. You may
///     wish to use <see cref="DocumentationRhoMLAttribute"/> to specify documentation with special markup for
///     command-line-related concepts, as well as <see cref="DocumentationEggsMLAttribute"/> for an alternative markup
///     language without command-line specific concepts.</remarks>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
public class DocumentationAttribute : Attribute
{
    /// <summary>
    ///     Gets the console-colored documentation string. Note that this property may throw if the text couldn't be parsed
    ///     where applicable.</summary>
    public virtual ConsoleColoredString Text { get { return OriginalText; } }
    /// <summary>Gets a string describing the documentation format to the programmer (not seen by the users).</summary>
    public virtual string OriginalFormat { get { return "Plain text"; } }
    /// <summary>Gets the original documentation string exactly as specified in the attribute.</summary>
    public string OriginalText { get; private set; }

    /// <summary>Constructor.</summary>
    public DocumentationAttribute(string documentation)
    {
        OriginalText = documentation;
    }
}

/// <summary>
///     Use this attribute to link a command-line option or command with the help text that describes (documents) it. Suitable
///     for single-language applications only. The documentation is to be specified in <see cref="RhoML"/>, which is
///     interpreted as described in <see cref="CommandLineParser.Colorize(RhoElement)"/>. See also <see
///     cref="DocumentationAttribute"/>.</summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
public class DocumentationRhoMLAttribute : DocumentationAttribute
{
    /// <summary>Gets a string describing the documentation format to the programmer (not seen by the users).</summary>
    public override string OriginalFormat { get { return "RhoML"; } }
    /// <summary>
    ///     Gets the console-colored documentation string. Note that this property may throw if the text couldn't be parsed
    ///     where applicable.</summary>
    public override ConsoleColoredString Text
    {
        get { return _parsed ?? (_parsed = CommandLineParser.Colorize(RhoML.Parse(OriginalText))); }
    }
    private ConsoleColoredString _parsed;
    /// <summary>Constructor.</summary>
    public DocumentationRhoMLAttribute(string documentation) : base(documentation) { }
}

/// <summary>
///     Use this attribute to link a command-line option or command with the help text that describes (documents) it. Suitable
///     for single-language applications only. The documentation is to be specified in <see cref="EggsML"/>, which is
///     interpreted as described in <see cref="CommandLineParser.Colorize(EggsNode)"/>. See also <see
///     cref="DocumentationRhoMLAttribute"/> and <see cref="DocumentationAttribute"/>.</summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
public class DocumentationEggsMLAttribute : DocumentationAttribute
{
    /// <summary>Gets a string describing the documentation format to the programmer (not seen by the users).</summary>
    public override string OriginalFormat { get { return "EggsML"; } }
    /// <summary>
    ///     Gets the console-colored documentation string. Note that this property may throw if the text couldn't be parsed
    ///     where applicable.</summary>
    public override ConsoleColoredString Text
    {
        get { return _parsed ?? (_parsed = CommandLineParser.Colorize(EggsML.Parse(OriginalText))); }
    }
    private ConsoleColoredString _parsed;
    /// <summary>Constructor.</summary>
    public DocumentationEggsMLAttribute(string documentation) : base(documentation) { }
}

/// <summary>
///     This is a legacy attribute. Do not use in new programs. This attribute is equivalent to <see
///     cref="DocumentationEggsMLAttribute"/>.</summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Class | AttributeTargets.Method, Inherited = false, AllowMultiple = false), RummageKeepUsersReflectionSafe]
public class DocumentationLiteralAttribute : DocumentationEggsMLAttribute
{
    /// <summary>Constructor.</summary>
    public DocumentationLiteralAttribute(string documentation) : base(documentation) { }
}

/// <summary>
///     Specifies that a specific command-line option should not be printed in help pages, i.e. the option should explicitly
///     be undocumented.</summary>
[AttributeUsage(AttributeTargets.Field | AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
public sealed class UndocumentedAttribute : Attribute
{
    /// <summary>Constructor.</summary>
    public UndocumentedAttribute() { }
}

/// <summary>Describes the behavior of an enum-typed field with the <see cref="EnumOptionsAttribute"/>.</summary>
public enum EnumBehavior
{
    /// <summary>Specifies that an enum is considered to represent a single value.</summary>
    SingleValue,
    /// <summary>Specifies that an enum is considered to represent a bitfield containing multiple values.</summary>
    MultipleValues
}

/// <summary>
///     Specifies that a field of an enum type should be interpreted as multiple possible options, each specified by an <see
///     cref="OptionAttribute"/> on the enum values in the enum type.</summary>
[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
public sealed class EnumOptionsAttribute : Attribute
{
    /// <summary>Constructor.</summary>
    public EnumOptionsAttribute(EnumBehavior behavior) { Behavior = behavior; }

    /// <summary>
    ///     Specifies whether the enum is considered to represent a single value or a bitfield containing multiple values.</summary>
    public EnumBehavior Behavior { get; private set; }
}

/// <summary>Specifies that the command-line parser should ignore a field.</summary>
[AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
public sealed class IgnoreAttribute : Attribute
{
    /// <summary>Constructor.</summary>
    public IgnoreAttribute() { }
}

/// <summary>Represents any error encountered while parsing a command line. This class is abstract.</summary>
[Serializable]
public abstract class CommandLineParseException : TranslatableException<Translation>
{
    /// <summary>Specifies the command-line type for which a help screen is to be output to the user on the console.</summary>
    internal CommandInfo CommandInfo { get; private set; }

    /// <summary>Contains the error message that describes the cause of this exception.</summary>
    public Func<Translation, ConsoleColoredString> GetColoredMessage { get; private set; }

    /// <summary>
    ///     Generates a printable description of the error represented by this exception, typically used to tell the user what
    ///     they did wrong.</summary>
    /// <param name="tr">
    ///     The translation class containing the translated text, or <c>null</c> for English.</param>
    /// <param name="wrapWidth">
    ///     The character width at which the output should be word-wrapped. The default (<c>null</c>) uses <see
    ///     cref="ConsoleUtil.WrapToWidth"/>.</param>
    public ConsoleColoredString GenerateErrorText(Translation tr, int? wrapWidth = null)
    {
        if (tr == null)
            tr = new Translation();

        var strings = new List<ConsoleColoredString>();
        var message = tr.Error.Translation.Color(CmdLineColor.Error) + " " + GetColoredMessage(tr);
        foreach (var line in message.WordWrap(wrapWidth ?? ConsoleUtil.WrapToWidth(), tr.Error.Translation.Length + 1))
        {
            strings.Add(line);
            strings.Add(Environment.NewLine);
        }
        return new ConsoleColoredString(strings);
    }

    /// <summary>Constructor.</summary>
    internal CommandLineParseException(Func<Translation, ConsoleColoredString> getMessage, CommandInfo commandInfo) : this(getMessage, commandInfo, null) { }
    /// <summary>Constructor.</summary>
    internal CommandLineParseException(Func<Translation, ConsoleColoredString> getMessage, CommandInfo commandInfo, Exception inner)
        : base(tr => getMessage(tr).ToString(), inner)
    {
        CommandInfo = commandInfo;
        GetColoredMessage = getMessage;
    }

    /// <summary>
    ///     Prints usage information, followed by an error message describing to the user what it was that the parser didn't
    ///     understand.</summary>
    /// <param name="applicationTr">
    ///     An object containing translations for the documentation strings. Set this to <c>null</c> only if your application
    ///     is definitely monolingual (unlocalisable).</param>
    /// <param name="tr">
    ///     Contains translations for the messages used by the command-line parser. Set this to <c>null</c> only if your
    ///     application is definitely monolingual (unlocalisable).</param>
    /// <param name="helpProcessor">
    ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
    ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
    public virtual void WriteUsageInfoToConsole(TranslationBase applicationTr = null, Translation tr = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
    {
        ConsoleUtil.Write(GetUsageInfo(applicationTr, tr, helpProcessor));
    }

    /// <summary>
    ///     Generates and returns usage information, followed by an error message describing to the user what it was that the
    ///     parser didn't understand.</summary>
    /// <param name="applicationTr">
    ///     An object containing translations for the documentation strings. Set this to <c>null</c> only if your application
    ///     is definitely monolingual (unlocalisable).</param>
    /// <param name="tr">
    ///     Contains translations for the messages used by the command-line parser. Set this to <c>null</c> only if your
    ///     application is definitely monolingual (unlocalisable).</param>
    /// <param name="helpProcessor">
    ///     Specifies a callback which is invoked on every documentation string retrieved from the <see
    ///     cref="DocumentationAttribute"/>s to generate the help text. This callback can modify the text arbitrarily.</param>
    public ConsoleColoredString GetUsageInfo(TranslationBase applicationTr = null, Translation tr = null, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor = null)
    {
        if (tr == null)
            tr = new Translation();
        var str = CommandLineParser.GenerateHelp(CommandInfo, ConsoleUtil.WrapToWidth(), applicationTr, tr, helpProcessor);
        if (WriteErrorText)
            str += Environment.NewLine + GenerateErrorText(tr, ConsoleUtil.WrapToWidth());
        return str;
    }

    /// <summary>
    ///     Determines whether <see cref="WriteUsageInfoToConsole"/> should call <see cref="GenerateErrorText"/> and output it
    ///     to the console. Default is <c>true</c>.</summary>
    /// <remarks>
    ///     Only set this to <c>false</c> if the user explicitly asked to see the help screen. Otherwise its appearance
    ///     without explanation is confusing.</remarks>
    protected internal virtual bool WriteErrorText { get { return true; } }
}

/// <summary>Indicates that the user supplied one of the standard options we recognize as a help request.</summary>
[Serializable]
public sealed class CommandLineHelpRequestedException : CommandLineParseException
{
    /// <summary>Constructor.</summary>
    internal CommandLineHelpRequestedException(CommandInfo commandInfo)
        : base(tr => tr.UserRequestedHelp.Color(ConsoleColor.Gray), commandInfo)
    {
    }

    /// <summary>Overrides the base to indicate that no error message should be output along with the help screen.</summary>
    protected internal override bool WriteErrorText { get { return false; } }
}

/// <summary>Specifies that the arguments specified by the user on the command-line do not pass the custom validation checks.</summary>
[Serializable]
public sealed class CommandLineValidationException : CommandLineParseException
{
    /// <summary>Constructor.</summary>
    internal CommandLineValidationException(ConsoleColoredString message, CommandInfo commandInfo) : base(tr => message, commandInfo) { }
}

/// <summary>
///     Specifies that the command-line parser encountered a command or option that was not recognised (there was no <see
///     cref="OptionAttribute"/> or <see cref="CommandNameAttribute"/> attribute with a matching option or command name).</summary>
[Serializable]
public sealed class UnrecognizedCommandOrOptionException : CommandLineParseException
{
    /// <summary>The unrecognized command name or option name.</summary>
    public string CommandOrOptionName { get; private set; }
    /// <summary>Constructor.</summary>
    internal UnrecognizedCommandOrOptionException(string commandOrOptionName, CommandInfo commandInfo) : this(commandOrOptionName, commandInfo, null) { }
    /// <summary>Constructor.</summary>
    internal UnrecognizedCommandOrOptionException(string commandOrOptionName, CommandInfo commandInfo, Exception inner)
        : base(tr => tr.UnrecognizedCommandOrOption.ToConsoleColoredString().Fmt(commandOrOptionName.Color(ConsoleColor.White)), commandInfo, inner)
    {
        CommandOrOptionName = commandOrOptionName;
    }
}

/// <summary>
///     Specifies that the command-line parser encountered a command or option that is not allowed in conjunction with a
///     previously-encountered command or option.</summary>
[Serializable]
public sealed class IncompatibleCommandOrOptionException : CommandLineParseException
{
    /// <summary>
    ///     The earlier option or command, which by itself is valid, but conflicts with the <see
    ///     cref="LaterCommandOrOption"/>.</summary>
    public string EarlierCommandOrOption { get; private set; }
    /// <summary>The later option or command, which conflicts with the <see cref="EarlierCommandOrOption"/>.</summary>
    public string LaterCommandOrOption { get; private set; }
    /// <summary>Constructor.</summary>
    internal IncompatibleCommandOrOptionException(string earlier, string later, CommandInfo commandInfo) : this(earlier, later, commandInfo, null) { }
    /// <summary>Constructor.</summary>
    internal IncompatibleCommandOrOptionException(string earlier, string later, CommandInfo commandInfo, Exception inner)
        : base(tr => tr.IncompatibleCommandOrOption.ToConsoleColoredString().Fmt(later.Color(ConsoleColor.White), earlier.Color(ConsoleColor.White)), commandInfo, inner)
    {
        EarlierCommandOrOption = earlier;
        LaterCommandOrOption = later;
    }
}

/// <summary>
///     Specifies that the command-line parser encountered the end of the command line when it expected an argument to an
///     option.</summary>
[Serializable]
public sealed class IncompleteOptionException : CommandLineParseException
{
    /// <summary>The name of the option that was missing an argument.</summary>
    public string OptionName { get; private set; }
    /// <summary>Constructor.</summary>
    internal IncompleteOptionException(string optionName, CommandInfo commandInfo) : this(optionName, commandInfo, null) { }
    /// <summary>Constructor.</summary>
    internal IncompleteOptionException(string optionName, CommandInfo commandInfo, Exception inner)
        : base(tr => tr.IncompleteOption.ToConsoleColoredString().Fmt(optionName.Color(ConsoleColor.White)), commandInfo, inner)
    {
        OptionName = optionName;
    }
}

/// <summary>
///     Specifies that the command-line parser encountered additional command-line arguments when it expected the end of the
///     command line.</summary>
[Serializable]
public sealed class UnexpectedArgumentException : CommandLineParseException
{
    /// <summary>Contains the first unexpected argument and all of the subsequent arguments.</summary>
    public string[] UnexpectedParameters { get; private set; }
    /// <summary>Constructor.</summary>
    internal UnexpectedArgumentException(string[] unexpectedArgs, CommandInfo commandInfo) : this(unexpectedArgs, commandInfo, null) { }
    /// <summary>Constructor.</summary>
    internal UnexpectedArgumentException(string[] unexpectedArgs, CommandInfo commandInfo, Exception inner)
        : base(tr => tr.UnexpectedParameter.ToConsoleColoredString().Fmt(unexpectedArgs.Select(prm => prm.Length > 50 ? prm.Substring(0, 47) + "..." : prm).FirstOrDefault().Color(CmdLineColor.UnexpectedArgument)), commandInfo, inner)
    {
        UnexpectedParameters = unexpectedArgs;
    }
}

/// <summary>
///     Specifies that a parameter that expected a numerical value was passed a string by the user that doesn’t parse as a
///     number.</summary>
[Serializable]
public sealed class InvalidNumericParameterException : CommandLineParseException
{
    /// <summary>Contains the name of the field pertaining to the parameter that was passed an invalid value.</summary>
    public string FieldName { get; private set; }
    /// <summary>Constructor.</summary>
    internal InvalidNumericParameterException(string fieldName, CommandInfo commandInfo) : this(fieldName, commandInfo, null) { }
    /// <summary>Constructor.</summary>
    internal InvalidNumericParameterException(string fieldName, CommandInfo commandInfo, Exception inner)
        : base(tr => tr.InvalidNumber.ToConsoleColoredString().Fmt("<".Color(CmdLineColor.FieldBrackets) + fieldName.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets)), commandInfo, inner)
    {
        FieldName = fieldName;
    }
}

/// <summary>
///     Specifies that the command-line parser encountered the end of the command line when it expected additional mandatory
///     options.</summary>
[Serializable]
public sealed class MissingParameterException : CommandLineParseException
{
    /// <summary>Contains the field pertaining to the parameter that was missing.</summary>
    public FieldInfo Field { get; private set; }
    /// <summary>Contains an optional reference to a field which the missing parameter must precede.</summary>
    public FieldInfo BeforeField { get; private set; }
    /// <summary>
    ///     Specifies whether the missing parameter was a missing option (true) or a missing positional parameter (false).</summary>
    public bool IsOption { get; private set; }
    /// <summary>Constructor.</summary>
    internal MissingParameterException(FieldInfo paramField, FieldInfo beforeField, bool isOption, CommandInfo commandInfo) : this(paramField, beforeField, isOption, commandInfo, null) { }
    /// <summary>Constructor.</summary>
    internal MissingParameterException(FieldInfo paramField, FieldInfo beforeField, bool isOption, CommandInfo commandInfo, Exception inner)
        : base(tr => getMessage(tr, paramField, beforeField, isOption), commandInfo, inner)
    { Field = paramField; BeforeField = beforeField; IsOption = isOption; }

    private static ConsoleColoredString getMessage(Translation tr, FieldInfo field, FieldInfo beforeField, bool isOption)
    {
        if (beforeField == null)
            return (isOption ? tr.MissingOption : tr.MissingParameter).ToConsoleColoredString().Fmt(field.FormatParameterUsage(true));

        return (isOption ? tr.MissingOptionBefore : tr.MissingParameterBefore).ToConsoleColoredString().Fmt(
            field.FormatParameterUsage(true),
            "<".Color(CmdLineColor.FieldBrackets) + beforeField.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
    }
}

/// <summary>
///     Specifies that the command-line parser encountered the end of the command line when it expected a mandatory
///     subcommand.</summary>
[Serializable]
public sealed class MissingSubcommandException : CommandLineParseException
{
    /// <summary>Constructor.</summary>
    internal MissingSubcommandException(CommandInfo commandInfo) : this(commandInfo, null) { }
    /// <summary>Constructor.</summary>
    internal MissingSubcommandException(CommandInfo commandInfo, Exception inner)
        : base(tr => tr.MissingSubcommand.ToConsoleColoredString(), commandInfo, inner)
    { }
}

static class CmdLineExtensions
{
    public static string[] GetOrderedOptionAttributeNames(this MemberInfo member)
    {
        var attr = member.GetCustomAttributes<OptionAttribute>().FirstOrDefault();
        return attr == null ? null : attr.Names.OrderBy(compareOptionNames).ToArray();
    }

    private static int compareOptionNames(string opt1, string opt2)
    {
        bool long1 = opt1.StartsWith("--");
        bool long2 = opt2.StartsWith("--");
        if (long1 == long2)
            return StringComparer.OrdinalIgnoreCase.Compare(opt1, opt2);
        else if (long1)
            return 1; // --blah comes after -blah
        else
            return -1;
    }

    public static ConsoleColoredString FormatParameterUsage(this FieldInfo field, bool isMandatory)
    {
        // Positionals
        if (field.IsDefined<IsPositionalAttribute>())
            return (isMandatory ? "{0}" : "[{0}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                "<".Color(CmdLineColor.FieldBrackets) + field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));

        // -t name [-t name [...]]    — arrays, multi-value enums with CommandNames
        if (field.FieldType.IsArray ||
            (field.FieldType.IsEnum &&
                field.IsDefined<OptionAttribute>() &&
                field.IsDefined<EnumOptionsAttribute>() &&
                field.GetCustomAttributes<EnumOptionsAttribute>().First().Behavior == EnumBehavior.MultipleValues))
        {
            return (isMandatory ? "{0} {1} [{0} {1} [...]]" : "[{0} {1} [{0} {1} [...]]]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
                field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option),
                "<".Color(CmdLineColor.FieldBrackets) + field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
        }

        // Enums with Option names
        if (field.FieldType.IsEnum && !field.IsDefined<OptionAttribute>())
        {
            var options = field.FieldType.GetFields(BindingFlags.Public | BindingFlags.Static)
                .Where(fld => fld.IsDefined<OptionAttribute>() && !fld.IsDefined<UndocumentedAttribute>())
                .Select(fi => fi.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option))
                .ToArray();

            if (field.IsDefined<EnumOptionsAttribute>() && field.GetCustomAttributes<EnumOptionsAttribute>().First().Behavior == EnumBehavior.MultipleValues)
                // [-t] [-u] [-v]    — multi-value enums with Option names
                return options.Select(opt => "[{0}]".Color(CmdLineColor.OptionalityDelimiters).Fmt(opt)).JoinColoredString(" ");

            // {-t|-u}      — single-value enums with Options
            return (isMandatory ? (options.Length > 1 ? "{{{0}{1}" : "{0}") : "[{0}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(options.JoinColoredString("|".Color(CmdLineColor.OptionalityDelimiters)), "}");
        }

        // -t       — bools
        if (field.FieldType == typeof(bool))
            return "[{0}]".Color(CmdLineColor.OptionalityDelimiters).Fmt(field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option));

        // -t name
        return (isMandatory ? "{0} {1}" : "[{0} {1}]").Color(CmdLineColor.OptionalityDelimiters).Fmt(
            field.GetOrderedOptionAttributeNames().First().Color(CmdLineColor.Option),
            "<".Color(CmdLineColor.FieldBrackets) + field.Name.Color(CmdLineColor.Field) + ">".Color(CmdLineColor.FieldBrackets));
    }

    public static ConsoleColoredString GetDocumentation(this MemberInfo member, Type inType, TranslationBase applicationTr, Func<ConsoleColoredString, ConsoleColoredString> helpProcessor)
    {
        if (member.IsDefined<DocumentationAttribute>())
            return helpProcessor(member.GetCustomAttributes<DocumentationAttribute>().Select(d => d.Text ?? "").First());
        if (applicationTr == null)
            return "";

        if (!(member is Type) && inType.IsSubclassOf(member.DeclaringType))
            inType = member.DeclaringType;
        var meth = inType.GetMethod(member.Name + "Doc", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[] { applicationTr.GetType() }, null);
        if (meth == null || meth.ReturnType != typeof(string))
            return "";
        var str = (string) meth.Invoke(null, new object[] { applicationTr });
        return str == null ? "" : helpProcessor(CommandLineParser.Colorize(EggsML.Parse(str)));
    }
}
