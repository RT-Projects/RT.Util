namespace RT.Serialization;

/// <summary>
///     Used by <see cref="Classify"/> to serialize and deserialize objects. Implement this to enable serialization to a new
///     format.</summary>
/// <typeparam name="TElement">
///     Type of the serialized form of an object or any sub-object.</typeparam>
public interface IClassifyFormat<TElement>
{
    /// <summary>
    ///     Reads the serialized form from a stream.</summary>
    /// <param name="stream">
    ///     Stream to read from.</param>
    /// <returns>
    ///     The serialized form read from the stream.</returns>
    TElement ReadFromStream(Stream stream);

    /// <summary>
    ///     Writes the serialized form to a stream.</summary>
    /// <param name="element">
    ///     Serialized form to write to the stream.</param>
    /// <param name="stream">
    ///     Stream to write to.</param>
    void WriteToStream(TElement element, Stream stream);

    /// <summary>
    ///     Determines whether the specified element represents a <c>null</c> value.</summary>
    /// <remarks>
    ///     This should return <c>true</c> if the element was generated by <see cref="FormatNullValue"/> and <c>false</c>
    ///     otherwise.</remarks>
    bool IsNull(TElement element);

    /// <summary>
    ///     Called when Classify expects the element to be one of the following types: <c>byte</c>, <c>sbyte</c>,
    ///     <c>short</c>, <c>ushort</c>, <c>int</c>, <c>uint</c>, <c>long</c>, <c>ulong</c>, <see
    ///     cref="System.Numerics.BigInteger"/>, <c>decimal</c>, <c>float</c>, <c>double</c>, <c>bool</c>, <c>char</c>,
    ///     <c>string</c>, <see cref="DateTime"/> or an enum type. The implementation is free to return a value of any of
    ///     these types, and Classify will automatically use <see cref="ExactConvert"/> to convert the value to the required
    ///     target type.</summary>
    /// <remarks>
    ///     This should decode values passed into <see cref="FormatSimpleValue"/>, although it is acceptable if the type has
    ///     changed, as long as <see cref="ExactConvert"/> will convert the decoded value back to the original value.</remarks>
    object GetSimpleValue(TElement element);

    /// <summary>
    ///     Decodes the serialized form of the element type itself.</summary>
    /// <remarks>
    ///     This should do the reverse of <see cref="FormatSelfValue"/>.</remarks>
    TElement GetSelfValue(TElement element);

    /// <summary>
    ///     Decodes a list.</summary>
    /// <param name="element">
    ///     The element to decode.</param>
    /// <param name="tupleSize">
    ///     If null, a variable-length list is expected; otherwise, a fixed-length list (a tuple) is expected.</param>
    /// <returns>
    ///     A collection containing the sub-elements contained in the list. The collection returned need not have the size
    ///     specified by <paramref name="tupleSize"/>.</returns>
    /// <remarks>
    ///     This should do the reverse of <see cref="FormatList"/>.</remarks>
    IEnumerable<TElement> GetList(TElement element, int? tupleSize);

    /// <summary>
    ///     Decodes a key-value pair.</summary>
    /// <param name="element">
    ///     The element to decode.</param>
    /// <param name="key">
    ///     Receives the key part of the pair.</param>
    /// <param name="value">
    ///     Receives the value part of the pair.</param>
    /// <remarks>
    ///     This should do the reverse of <see cref="FormatKeyValuePair"/>.</remarks>
    void GetKeyValuePair(TElement element, out TElement key, out TElement value);

    /// <summary>
    ///     Decodes a dictionary.</summary>
    /// <param name="element">
    ///     The element to decode.</param>
    /// <returns>
    ///     A collection containing the key/value pairs in the dictionary. The keys in the returned collection are expected to
    ///     be convertible to the correct type using <see cref="ExactConvert"/>.</returns>
    /// <remarks>
    ///     This should decode values passed into <see cref="FormatDictionary"/>, although it is acceptable if the type of the
    ///     keys has changed. For example, all keys may be returned as <c>string</c>, as long as <see cref="ExactConvert"/>
    ///     will convert that <c>string</c> back to the original value.</remarks>
    IEnumerable<KeyValuePair<object, TElement>> GetDictionary(TElement element);

    /// <summary>
    ///     Decodes a piece of raw data.</summary>
    /// <param name="element">
    ///     The element to decode.</param>
    /// <returns>
    ///     The raw data decoded.</returns>
    /// <remarks>
    ///     This should decode values passed into <see cref="FormatRawData"/>.</remarks>
    byte[] GetRawData(TElement element);

    /// <summary>
    ///     Determines whether the element is an object and contains a sub-element for the specified field.</summary>
    /// <param name="element">
    ///     The element that may represent an object.</param>
    /// <param name="fieldName">
    ///     The name of the field sought.</param>
    /// <param name="declaringType">
    ///     The assembly-qualified name of the type that declares the field. (This can be null if the field name is unique
    ///     within the type of the object being deserialized.)</param>
    /// <returns>
    ///     <c>true</c> if <paramref name="element"/> is an object and has the specified field; <c>false</c> otherwise.</returns>
    /// <remarks>
    ///     This should return <c>true</c> if <paramref name="element"/> represents an element generated by <see
    ///     cref="FormatObject"/> in which the field with the specified <paramref name="fieldName"/> was present.</remarks>
    bool HasField(TElement element, string fieldName, string declaringType);

    /// <summary>
    ///     Returns the sub-element pertaining to the specified field.</summary>
    /// <param name="element">
    ///     The element that represents an object.</param>
    /// <param name="fieldName">
    ///     The name of the field within the object whose sub-element is sought.</param>
    /// <param name="declaringType">
    ///     The assembly-qualified name of the type that declares the field. (This can be null if the field name is unique
    ///     within the type of the object being deserialized.)</param>
    /// <returns>
    ///     The sub-element for the specified field.</returns>
    /// <remarks>
    ///     <para>
    ///         Classify calls <see cref="HasField"/> first for each field and only calls this method if <see
    ///         cref="HasField"/> returned true.</para>
    ///     <para>
    ///         This should return the same element that was passed into <see cref="FormatObject"/> for the same <paramref
    ///         name="fieldName"/>.</para></remarks>
    TElement GetField(TElement element, string fieldName, string declaringType);

    /// <summary>
    ///     Determines the type of the object stored in the specified element.</summary>
    /// <param name="element">
    ///     The element that represents an object.</param>
    /// <param name="isFullType">
    ///     Receives a value indicating whether the type is a fully-qualified type name or not. This value is ignored if the
    ///     method returns <c>null</c>.</param>
    /// <returns>
    ///     <c>null</c> if no type information was persisted in this element; otherwise, the decoded type name.</returns>
    /// <remarks>
    ///     This should decode the information (the string and the boolean) encoded by <see cref="FormatWithType"/>.</remarks>
    string GetType(TElement element, out bool isFullType);

    /// <summary>
    ///     Determines whether this element represents a reference to another object in the same serialized graph.</summary>
    /// <param name="element">
    ///     The element to decode.</param>
    /// <returns>
    ///     <c>true</c> if this element represents such a reference; <c>false</c> otherwise.</returns>
    /// <remarks>
    ///     This should recognize elements generated by <see cref="FormatReference"/>.</remarks>
    bool IsReference(TElement element);

    /// <summary>
    ///     Determines whether this element represents an object that can be referred to by a reference element.</summary>
    /// <param name="element">
    ///     The element to decode.</param>
    /// <returns>
    ///     <c>true</c> if this element is referable; <c>false</c> otherwise.</returns>
    /// <remarks>
    ///     This should recognize elements generated by <see cref="FormatReferable"/>.</remarks>
    bool IsReferable(TElement element);

    /// <summary>
    ///     Returns the ID encoded in this element. This is called only if <see cref="IsReference"/> or <see
    ///     cref="IsReferable"/> returned <c>true</c>.</summary>
    /// <param name="element">
    ///     The element to decode.</param>
    /// <returns>
    ///     The ID encoded in this element.</returns>
    /// <remarks>
    ///     This should return the same ID that was passed into <see cref="FormatReference"/> or <see
    ///     cref="FormatReferable"/>.</remarks>
    int GetReferenceID(TElement element);

    /// <summary>
    ///     Generates an element that represents a <c>null</c> value.</summary>
    /// <returns>
    ///     The serialized form of the <c>null</c> value.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="IsNull"/>.</remarks>
    TElement FormatNullValue();

    /// <summary>
    ///     Generates an element that represents a <c>byte</c>, <c>sbyte</c>, <c>short</c>, <c>ushort</c>, <c>int</c>,
    ///     <c>uint</c>, <c>long</c>, <c>ulong</c>, <see cref="System.Numerics.BigInteger"/>, <c>decimal</c>, <c>float</c>,
    ///     <c>double</c>, <c>bool</c>, <c>char</c>, <c>string</c>, <see cref="DateTime"/> or an enum value.</summary>
    /// <param name="value">
    ///     The value to encode.</param>
    /// <returns>
    ///     The serialized form of the <paramref name="value"/>.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="GetSimpleValue"/>, but need not necessarily decode to the
    ///     same type, as long as <see cref="ExactConvert"/> will convert it to the correct value.</remarks>
    TElement FormatSimpleValue(object value);

    /// <summary>
    ///     Generates an element that represents a value of the same type as serialized elements.</summary>
    /// <param name="value">
    ///     The value to encode.</param>
    /// <returns>
    ///     The serialized form of the <paramref name="value"/>.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="GetSelfValue"/>.</remarks>
    TElement FormatSelfValue(TElement value);

    /// <summary>
    ///     Generates an element that represents a list.</summary>
    /// <param name="isTuple">
    ///     Specifies whether we are serializing a variable-length list, or a tuple (fixed-length list).</param>
    /// <param name="values">
    ///     The values to put into list form.</param>
    /// <returns>
    ///     The serialized list.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="GetList"/>.</remarks>
    TElement FormatList(bool isTuple, IEnumerable<TElement> values);

    /// <summary>
    ///     Generates an element that represents a key-value pair.</summary>
    /// <param name="key">
    ///     The element that represents the key.</param>
    /// <param name="value">
    ///     The element that represents the value.</param>
    /// <returns>
    ///     The serialized key-value pair.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="GetKeyValuePair"/>.</remarks>
    TElement FormatKeyValuePair(TElement key, TElement value);

    /// <summary>
    ///     Generates an element that represents a dictionary.</summary>
    /// <param name="values">
    ///     The key-value pairs that compose the dictionary. The keys may be <c>string</c>s, integers, or enum values.</param>
    /// <returns>
    ///     The serialized dictionary.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="GetDictionary"/>.</remarks>
    TElement FormatDictionary(IEnumerable<KeyValuePair<object, TElement>> values);

    /// <summary>
    ///     Generates an element that represents an object with fields.</summary>
    /// <param name="fields">
    ///     A collection of objects containing each fields’ identifying information and serialized value.</param>
    /// <returns>
    ///     The serialized object.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="HasField"/> and <see cref="GetField"/>, irrespective of
    ///     the order in which the fields are provided in <paramref name="fields"/>.</remarks>
    TElement FormatObject(IEnumerable<ObjectFieldInfo<TElement>> fields);

    /// <summary>
    ///     Generates an element that represents raw data (<c>byte[]</c>).</summary>
    /// <param name="value">
    ///     The raw data to store.</param>
    /// <returns>
    ///     The serialized raw data.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="GetRawData"/>.</remarks>
    TElement FormatRawData(byte[] value);

    /// <summary>
    ///     Generates an element that represents a reference to another object within the same serialized object graph.</summary>
    /// <param name="refId">
    ///     The reference ID.</param>
    /// <returns>
    ///     An element that represents a reference to another object with the specified <paramref name="refId"/>.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="IsReference"/>.</remarks>
    TElement FormatReference(int refId);

    /// <summary>
    ///     Converts an existing element (which may represent, for example, an object, list or dictionary) into one that can
    ///     be referred to by a reference (see <see cref="FormatReference"/>).</summary>
    /// <param name="element">
    ///     The original element to be converted.</param>
    /// <param name="refId">
    ///     The reference ID.</param>
    /// <returns>
    ///     A representation of the original <paramref name="element"/>, which additionally encodes the referable <paramref
    ///     name="refId"/>.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="IsReferable"/> as well as all the other methods that would
    ///     have also recognized the original <paramref name="element"/>.</remarks>
    TElement FormatReferable(TElement element, int refId);

    /// <summary>
    ///     Converts an existing element (which may represent, for example, an object, list or dictionary) into one that
    ///     additionally knows its type.</summary>
    /// <param name="element">
    ///     The original element to be converted.</param>
    /// <param name="type">
    ///     A string that identifies the type of the object.</param>
    /// <param name="isFullType">
    ///     A value indicating whether this is a fully-qualified type name or not.</param>
    /// <returns>
    ///     A representation of the original <paramref name="element"/>, which additionally encodes the <paramref
    ///     name="type"/>.</returns>
    /// <remarks>
    ///     The returned element should be recognized by <see cref="GetType"/> as well as all the other methods that would
    ///     have also recognized the original <paramref name="element"/>.</remarks>
    TElement FormatWithType(TElement element, string type, bool isFullType);

    /// <summary>
    ///     Throws an InvalidOperationException informing the user that an element is a reference (<see cref="IsReference"/>)
    ///     but the corresponding referable has not been encountered while deserializing.</summary>
    /// <param name="refID">
    ///     The numeric reference ID.</param>
    void ThrowMissingReferable(int refID);
}

/// <summary>
///     Encapsulates information about a field in an object and its value.</summary>
/// <typeparam name="TElement">
///     Type of serialized form used in <see cref="IClassifyFormat{TElement}"/>.</typeparam>
public sealed class ObjectFieldInfo<TElement>
{
    /// <summary>The name of the field.</summary>
    public string FieldName { get; private set; }
    /// <summary>
    ///     The assembly-qualified name of the type that declares the field, or null if the name of the field is unique within
    ///     the object being serialized.</summary>
    public string DeclaringType { get; private set; }
    /// <summary>The value of the field.</summary>
    public TElement Value { get; private set; }

    /// <summary>
    ///     Constructor.</summary>
    /// <param name="fieldName">
    ///     The name of the field.</param>
    /// <param name="declaringType">
    ///     The assembly-qualified name of the type that declares the field, or null if the name of the field is unique within
    ///     the object being serialized.</param>
    /// <param name="value">
    ///     The value of the field.</param>
    public ObjectFieldInfo(string fieldName, string declaringType, TElement value)
    {
        FieldName = fieldName;
        DeclaringType = declaringType;
        Value = value;
    }
}
